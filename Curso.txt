Seção 1 - Visão Geral

- Visão geral do curso Desenvolvimento Web 
01. Visão Geral                     14. Ajax                                
02. Configuração do Ambiente        15. Gulp   
03. Fundamentos                     16. Webpack
04. Estruturas de Controle          17. jQuery
05. Funções                         18. Bootstrap
06. Objetos & OO                    19. React
07. Array                           20. Vue
08. Node                            21. Bancos de Dados Relacionais 
09. Es Next... 6,7,8                22. Bancos de Dados não Relacionais
10. Fundamentos da Web              23. Express 
11. HTML                            24. Integrando Banco de Dados com o Backend
12. CSS                             25. Projetos    
13. DOM                             26. Outros Tópicos  
                                    27. Conclusão

- Repositório do Curso
Github: https://github.com/cod3rcursos/web-moderno 

- Boas Práticas do Suporte
. Para solucionar as dúvidas, dê muitas informações, como por exemplo: qual a versão, qual sistema operacionais, 
menasagens do terminal, cód em texto..
. Aprenda com os erros.
. Stak Overflow - para tirar dúvidas.
. Ajude outros estudantes.

- Importância dos Fundamentos
Para ter um bom resultado ter uma base sólida, ter paciência e calma, pausar e analisar o que está sendo feito.

- Por que aprender Javascript?
. Javascript é a linguagem da web, podendo construir app para multiplataformas está presente no back-end também.
. A sintaxe do Javascript é parecida com Java, C. 

- Usando o terminal
. Prompt de Comando - Dois artigos para utilizar o terminal.
. Windows -> https://blog.cod3r.com.br/terminal-no-windows/

Seção 2 - Configuração do Ambiente. 

- Aviso importante aos usuários de Windows
. Não utilizar a Área de Trabalho como localização para projetos.
. Desativar as sicronizações do OneDrive para não arquivar para nuvem os projetos. 

- Instalação Node - Windows  
. nodejs.org versão - 8.9.1 LTS
. Confirmar no Prompt de Comando a versão.

- Instalar Node e Visual Studio Code em Linux
. Não necessário.

- Configuração do Editor (VSCode)
. Instalação do VSCode 
. Prompt de comando - code -- version
. Extensões: Code Runner - Ctrl+Alt+N - Executa o código.

- Como abrir os Terminais nos Sistemas Operacionais
. Tecla Windows + R e digitar cmd
. Pesquisas no VSCode Ctrl+Shift+P

- Configuração do Comando 'code' 
. code .pasta que quiser abrir

- Instalação do VSCode
. Não necessário.

Seção 3 - Iniciando com Programação

- Introdução do Módulo 
. Base de conceitos da programação.

- Conhecendo o Visual Studio Code
Explorer - Onde ocorre a criação de pastas e arquivos.
Para cada arquivo aberto, será aberto uma nova aba
Ctrl+Alt+N - Executa o código. 
Ctrl+S - Salva os arquivos.

- Sentença de Código #01
. Dois conceitos importantes:
Sentença de código - entender o que é uma sentença de código. (Frases)
Bloco de código - entender o que é um bloco de código.        (Paragráfos)

Na sentença de código em Javascript, ao final precisa acrescentar ";" para finalizar. 
Pode ser ocupado várias linhas sendo apenas uma sentença de código, no meio de "" não
é possível pular linhas pois irá contar um erro. 
Espaços não são tão importantes mas irá ter uma organização melhor. 

Para cada sentença de código tem como objetivo transmitir uma sentença para o computador realizar as 
instruções informadas. 

- Sentença de Código #02
Como executar algo no CMD ou Terminal - console.log("Escreva o que será mostrado no terminal");
Será executado tanto com " " ou ' '
O programa será executado em uma sequência de passos.
A ordem das sequência é importante, será executado linha por linha.

- Comentários de Código
. Para realizar um Comentário no JS é necessário // ou para comentar em múltiplas linhas /* */. 

- Bloco de Código
. O conceito de blocos de código é muito importante, entender o porque da criação e o propósito da criação.
. Entender a sintaxe da lingua que você está estudando/trabalhando, que tipo de símbolos, pontuação, e o conceito
para facilitar o aprendizado de outras linguagens. 

Como definir um bloco de código em Javascript
. Para executar um comando ao final é acrescentado ;
. Um bloco de código em java é definido por um par de { e aqui será colocado a sentença de cód sendo agrupado }.
. Pode ser acrescentado várias setenças de códigos em um bloco. 
. Poderá acrescentar outro bloco dentro de outro bloco de código respeitando sempre a abertura e o fechamento,
por exemplo:
{
   {

   }
}
. Ele só irá executar com sucesso, se não estiver detectando nenhum erro. 
. Não faz sentido ter um bloco vázio.

- O código é organizado por:
Pastas
Arquivos de determinados tipos de extensões como js, py, c, cpp
Nos arquivos terá sentenças de códigos, juntamente com o bloco de código. 

- Desafio Sentença e Bloco
.Exibir Números Ímpares e Números Pares no console em diferentes blocos.

Para comentar múltiplas linhas pode ser adicionado com Ctrl+/
Para duplicar uma Frases Alt+Shift+Seta para baixo.
Excluir Linhas Ctrl+X
Para números decimais é escrito com . Ex: 6.1

- Trabalhando com Dados #01
. Cada sentença de código existe uma relação com dados, por exemplo console.log(7.9);
a parte escrita 7.9 - isto é um dado, um texto direto é um valor literal.
. Variável o conceito é armazenar uma informação. Por exemplo var quantidade = 10;
onde o nome da Variável é quantidade e o valor armazenado é 10.
. A forma mais moderna para definir uma Variável é Let, mas tem diferenças.

- Trabalhando com Dados #02
. Variável é declarado com - var. 
. Após declarar a váriavel, é informado o identificador onde você cria com um nome atribuindo ou não um valor.
Exemplo : var idade = 15; var nome = maria
. Também é possível realizar com let, por exemplo: let nome = josé; let idade = 10;
. Para apresentar uma variável concatenada com a outra no console acrescente + 

- Trabalhando com Dados #03
. Tipos de dados mais utilizados no Javascript
Typeof - É o tipo do valor.
Number - Números.
String - É uma sequência de caracteres utilizando letras ou números, ao utilizar uma string terá que
colocar dentro de "" ou ''.
. Javascript não faz diferenciação de números inteiros e de números decimais.
. O ponto pode ser flutuante, não mundando a categoria Number do Javascript.

- Trabalhando com Dados #04
. Poderá mudar o valor da variável, modificando ou substituindo com o símbolo de atribuição que é = 
por exemplo:
let a = 3;
//...
a = 10;

. Poderá também acrescentar outro valor, por exemplo: 
let a = 3;
a = a + 10;

. Quando é declarado uma váriavel constante por exemplo:
Const b = 2; 
Então essa variável será constante, não podendo ser modificada ou alterada no programa. 
Caso altere, constará um erro. 

- Desafio Área de Circunferência
. Calcular área de circunferência.

PI no Javascript -  Math.PI 

- Desafio Troca de Valores.
. Realizar troca de dados entre as variáveis.

Seção 4 - JavaScript: Fundamentos

- Visão Geral do Algoritmo. 
. Conceito de Algoritmo, independente da linguagem que está usando, o Algoritmo seria o verbo,
a ação, o processar dos passos.
. O Algoritmo é uma sequência de passos. Podendo executar uma sequência de passos, ou podendo ter repetições,
decisões e condições.
Decisão: decidir executar um passo ou não, de acordo com as condições do Algoritmo.
Repetições: repetir determinados passos em uma quantidade certa ou em uma intederminada quantidade de passos, de 
acordo com a execução do Algoritmo.
. O Algoritmo pode ser representado por:
Fluxograma.
Linguagem Natural.
Linguagem artificial.
Pseudo-linguagem.

Algoritmo vs Linguagem
. Existem várias linguagens de programação, quanto mais alto nível é a linguagem mais fácil a interpretação para 
o ser humano, quanto mais baixo o nível é mais próximo do computador. Se a linguagem possue mais recursos o Algoritmo
irá ficar mais simples, se a linguagem tem menos recursos provavelmente seu Algoritmo irá ficar mais complicado 
para que consiga chegar no mesmo resultado. 

- Visão Geral de Estruturas de Dados.
. O que são Estruturas de Dados? - Estrutura de Dados visa organizar e administrar os Dados.
Listas: uma sequência de passos ou condições.
Fifo: O primeiro a entrar na fila, irá ser o primeiro a sair. 
Lifo: O último a entrar na pilha, é o primeiro a sair. 
Árvore: Sistema de arquivos, com pastas e documentos.
Tabela: Segue entre linhas e colunas.

Estruturas de Dados básicas:
Int - Números inteiros.
Real - Números reais.
Letras - Caracteres.
Bool - Valores Booleanos como verdadeiro ou falso.

Sequência de letras - dependendo da linguagem.

Váriaveis e Constantes
. Para armazenar dados, em duas maneiras, variáveis podendo ser alterado o valor e constante quando o valor
é fixo. Então é para determinar algum valor para realizar um Algoritmo, mais simples. 

- Configuração do Projeto.
. Criação de Pastas do arquivo.
. Criação de arquivo durante as sessões.

- Organização Básica de um Código Js.
. Sentenças de Código: São linhas de códigos, podendo ocupar mais de uma linha, a sentença de código terminará com ; 
. Blocos de Código: São agrupamento das sentenças de códigos, para realizar determinada ação, delimitado por {}, existem 
blocos associados a uma função, a uma classe, a um objeto, a uma estrutura de controle, também aos testes. O bloco poderá
ter outro dentro. 
. Os espaçamentos servem para visualmente ver a hierarquia.

- Executando Javascript.
. Formas diferentes de executar javascript:
    - Ferramentas online.
    - Browser.
    - Node.
    - VsCode.
    - Editores de códigos.
Extensão VsCode:
. Code Runner.

- Comentários de Código.
. Para realizar um comentário utilizar //, para comentar em múltiplas linhas utilizar /*       */.
. Utilizar comentários que relevam o código, que auxiliam no decorrer do código.
. Tenha código legíveis, com nomes claros.
. Comente tudo que você acha necessário durante o curso. 

- O básico de Var, Let e Const.
. Variáveis: Os identificadores são muito importantes, colocar bons nomes, facilita o entendimento para manusear o 
código, o valor pode ser alterado durante o código, evite mudar o valor.
. Let: É uma nova forma de declarar uma váriavel, porém tem diferenças e outra forma de utilizar.
. Constante: O valor será fixo, sem alterações.

- Tipagem Fraca
. Como a linguagem irá lidar com os dados. 
. Cada linguagem tem sua forma de tipagem, no caso do javascript é uma tipagem simples, fraca.
. Evite nomes genéricos e siglas.

- Tipos em Javascript: Number.
. O numero pode ser declarado com ou sem função Number.
. Para verificar se o número é inteiro utilize - Number.isInteger
. Para diminuir as casas decimais e ter um controle sobre, basta acrescentar após a variavel - .toFixed 
. Para converter um valor para String utilize - .toString
. Para converter o valor em número binário utilize - .toString(2)

- Number: Alguns Cuidados.
. Utilizar 0 nas divisões em outras linguagens podem causar erros, porém no javascript é apresentado o Infinity.
. Utilizar "" como - console.log("10" / 2); Em outras linguagens pode ocorrer erros, porém no javascript ele consegue
converter a string pelo tipo de Number.
. console.log("show!" * 2); - Em algumas linguagens é capaz de multiplicar a string, mas no javascript ocorrerá um erro
NaN.
. console.log(0.1 + 0.7); - Por conta da especificação e também por conta do ponto flutuante o javascript não informará 
o número correto.
. console.log(10.toString()); - Não é possível utilizar o literal com a função para isso é preciso colocar entre () 
por exemplo: console.log((10.345).toFixed(2));

- Usando Math
. É um objeto do Javascript
. Math.PI - Constante que é o valor de PI.
. Math.pow - Função que calcula uma potência.

- Tipos em Javascript: String.
. É uma cadeia de caracteres, que no javascript pode ser delimitada por três símbolos:
Aspas duplas - " " 
Aspas simples - ' '
Crase - ´ ´ - para usar crase deve estar fazendo tamplate string, que são strings que permitem expressões embutidas 
pode utilizar string multi-linhas e interpolação de string com elas.
. .charAt() - Resultará a letra da string conforme o número informado no ().
. .charCodeAt - Código relacionado a tabela ASCII ou Unicode, com relação ao índice informado no ().
. .indexOf() - Índice informado se houver o valor associado a ele na string.
. .substring() - Mostrará o restante da string informada a partir do valor no (). 
console.log("Escola ".concat(escola).concat("!")); - Função de concatenar, um valor literal e acrescentar outro valor 
literal.
. .replace(3, "e") - para substituir conforme alteração entre ().
. .split(",") - Gera um array sobre a string, ao utilizar entre () é informado o separados do conteúdo informado 
no código.

- Usando Template strings.
. Adição na linguagem Javascript em 2015.
. Organiza e deixa o código com mais clareza.
. É permitido a quebra de linha no Template, utilizar a crase para digitar por exemplo: 
const template = `
    Olá
    ${nome}!`;
. Template será interpretado no ${    }

- Tipos em Javascript: Boolean 
. Boolean é uma função que separa o verdadeiro e falso e realiza determinadas condições conforme as condições informadas
no código.
. Tipos de valores verdadeiro. Exemplo:
console.log("Os Verdadeiros");
console.log(!!3);
console.log(!!-1);
console.log(!!"teste");
console.log(!![]);
console.log(!!{});
console.log(!!Infinity);
console.log(!!(isAtivo = true));

. Tipos de valores falso. Exemplo:
console.log("Os Falsos");
console.log(!!0);
console.log(!!'');
console.log(!!null);
console.log(!!NaN);
console.log(!!undefined);
console.log(!!(isAtivo = false));

. Para informar o valor verdadeiro ou falso é preciso digitar: !!
. Para transformar um valor em verdadeiro ou falso é utilizado: !

- Tipos em Javascript: Array.
. É uma objeto de agrupar multiplos valores, com uma única estrutura a partir de um índice.
. Realiza um agrupamento, em forma de vetor (um elemento em seguida do outro).
. O acesso de um Array é a partir de um número. (A partir do indíce 0).
. Em javascript o Array é possível utilizar string, números, podendo ter mudanças, não necessário ser um valor fixo.
. Em Java o Array é fixo.
. Quando é passado do valor de indíce ocorre um erro no array então aparece undefined. (Em outras linguagens também
ocorre erros).
. [ ] - Para iniciar um array.
. .length - Para verificar quantos elementos tem no array.
. .push - Para adicionar outros elementos.
. Mesmo sendo possível acrescentar vários tipos de elementos no array, o ideal é ter um array para cada elemento.
. .pop(0) ou delete       [0]; - Para excluir elementos.

- Tipos em Javascript: Object.
. Anotação literal de objetos.
. {} - Para escrever um objeto.
. É possível criar o nome após a variável de objeto, o objeto é coleção de chave com valores, podendo ser um string,
number ou uma função.
. É possível também ter um outro objeto, por exemplo: um produto sendo objeto, e uma categoria.
. Dentro de um objeto é apenas um único identificador, por exemplo:

const prod1 = {};
prod1.nome = "Celular Ultra Mega"
prod1.preco = 4999.90
console.log(prod1);

. Evitar atributos com espaço.
. Json é um formato textual. 

- Entendendo Null & Undefined.
. Null - Ausência de valor
. Undefined - Valor não definido
. Null é presente entre várias linguagens.
. Quando for necessário zera uma variável que consta em um objeto ou uma função, a melhor opção é colocar null.
. Undefined é melhor deixar o programa definir. 
. Sempre ter um valor padrão associado a variável. 
. Quando tem uma atribuição por valor, é realizado uma cópia do valor e cada variável ou constante vai ter o valor
independente.
E quando é realizado uma atribuição de referência, ou seja, copiando um endereço de memória, as duas variáveis ou 
constante terminam no mesmo lugar.
. Quando uma variável está nula, não é possível acessar nenhum membro, nenhuma função, nenhum atributo.

- Quase tudo é Função.
. Exerce um papel central na linguagem javascript. 
. Para criação de uma função o início é class   {}
. Função pode ter atributos, outra função, é possível armazenar uma função em uma váriavel.

- Exemplos Básicos de Funções #01.
. Uma função é uma ação, executa um processo, baseado em uma sentença de código definindo um bloco.
. Agrupando as sentenças de código, recebendo parâmetros de entrada, retornando um valor.
. Podendo não receber nenhum parêmetro, pode não retornar dados.

- Exemplos Básicos de Funções #02.
. É possível armazenar uma função dentro de uma variável.
. Um novo método de reduzir uma função dentro de uma variável é utilizando o método de arrow function.
. Arrow function traz uma sintaxe mais reduzida, para respresentar a função é utilizado => e return
. Exemplo de uma forma reduzida: const imprimir2 = a => console.log(a);.  

- Declaração de Variáveis com VAR #01.
. A variável estando ou não dentro de um bloco será visível.
. Para resultar a váriavel na função é necessário realizar dentro da função pois se informar fora ocorrerá um erro
de definição.
. Então Var tem dois escopos possíveis, ou é nível global: visível na aplicação inteira, por exemplo pelo Browser ou
é criado um escopo de função, que será somente visível na função.

- Declaração de Variáveis com VAR #02.
. É possível declarar uma var com o mesmo nome, porém uma dentro de um bloco e outra fora. Por exemplo:

var numero = 1;
{
    var numero = 2;
    console.log("Dentro =", numero);
}
console.log("Fora =", numero);

- Declaração de Variáveis com LET
. A diferença entre var e let, o let tem três escopos possíveis, nível global: visível na aplicação inteira, por 
exemplo pelo Browser ou é criado um escopo de função, que será somente visível na função
ou é um escopo pelo bloco.

- Usando VAR em loop #01.
. Exemplo de conceito de loop com var.
. Usando o laço FOR.
. Existem formas de estrutura de controle, podendo executar a partir de uma 
determinada condição.
 
- Usando LET em Loop #01.
. No caso LET, a variável só estará visivel caso esteja no bloco de repetição 
por exemplo: 
. for (let i = 0; i < 10; i++){
    console.log(i);
}
console.log("i =", i);
. Nesse caso como está fora do bloco, o console.log constará um erro de 
definição da variável pois LET só será visivel e reconhecido se estiver dentro 
do bloco.

- Usando VAR em loop #02.
. As declarações de var tem escopo global ou de função. Variáveis de var podem 
ser atualizadas e declaradas novamente dentro de seu escopo.
. Exemplo em JS.
 
- Usando LET em Loop #02.
. As declarações de let e de const têm escopo de bloco. As variáveis de let 
podem ser atualizadas, mas não podem ser declaradas novamente.
. Exemplo em JS.

- Entendendo o Hoisting.
. Hoisting é o termo que explica essa situação, em português ele significa 
“içamento”, ou “elevação”. O Hoisting permite que você execute funções antes 
das suas declarações.
. Não é viável fazer o Hoisting, pois poderá confundir e até causar erros.
. Com VAR é possível realizar exemplos como esse: 
function teste() {
    console.log("a =", a);
    var a = 2;
    console.log("a =", a);
}
teste();
console.log("a =", a);

. Sendo que, o primeiro valor irá gerar undefined e o valor seguinte irá gerar 
2.
. Porém com LET, ocorerá um erro de valor não definido.

- Função vs Objeto.
. A função pode ser instanciada pela palavra new, por exemplo: 
console.log(typeof new Cliente);
. Também é possível instanciar com class, por exemplo:
class Produto { } // ES 2015 (ES6)
console.log(typeof Produto);
console.log(typeof new Produto());
. O objeto é coleção de chaves com valores. Podendo ser criado um valor, usando 
um objeto inicializados, alternativamente, podendo criar uma função construtora 
e depois instaniar a um objeto usando aquela função com o new.

- Par Nome/valor
. Objeto são grupos aninhados de pares nome/valor, podendo ter um objeto dentro 
de outro.
. Exemplo em JS.

- Notação Ponto.
. Pode ter acesso a atributos que estão visível dentro de um determinado 
objeto, membros de uma função.
. this.nome - Pode tornar a função pública, pode atribuir para instanciar Obj.

- Operadores: Atrubuição.
. Atrubuição é representado pelo símbolo de = .

- Operadores: Destructuring #01.
. Exemplo de Destructuring: Objeto
. É um operador introduzido em 2015 no JS.
. É um operador de desestruturação, retira alguma coisa de uma estrutura.
. Por exemplo: tirar elementos de um Objeto, é utilizado a sintaxe de { }, porque está desestruturando de um objeto.

const pessoa = {
    nome: "Ana",
    idade: 5,
    endereco: {
        logradouro: "Rua ABC",
        numero: 1000
    }
}

const {nome,idade} = pessoa; 
console.log(nome,idade);

. Caso tente desestruturar um dado alinhado, verifique se o dado está citado, pode ocorrer do último dado está undefined. 
Caso os dados não estejam alinhados, irá ocorrer um erro como esse exemplo:
TypeError: Cannot read properties of undefined.

- Operadores: Destructuring #02.
. Exemplo de Destructuring: Array.
const [a] = [10];
console.log(a);

const [n1, , n3, , n5, , n6 = 0] = [10,7,9,8];
console.log(n1,n3,n5,n6);

const [, [, nota]] = [[, 8, 8], [9, 6, 8]]; 
console.log(nota);
. Para desestruturação de array é utilizado a sintaxe de [], para isso terá que ser analisado se está criando um array
do lado direito, ou utilizando Destructuring do lado esquerdo.

- Operadores: Destructuring #03.
. Exemplo de Destructuring: Função.
. Pode ser utilizados para vários padrões diferentes, usando a mesma função, por exemplo:

function rand({min = 0, max = 1000}){
    const valor = Math.random() * (max - min) + min;
    return Math.floor(valor);
}
const obj = {max: 50, min: 40};
console.log(rand(obj));
console.log(rand({min: 955}));
console.log(rand({}));
console.log(rand());

- Operadores: Destructuring #04.
. Utilizando Destructuring em um Array dentro dos parâmetros de uma Função. 
. É uma forma simples de extrair ou criar algum elemento dentro de array e objetos. Sabendo que recebendo um objeto 
dentro de uma função, podendo retirar algum dado modificando 
com Destructuring.

- Operadores: Aritméticos.
. São operadores binários.
. Quando dois valores operando.
Postfix - n++ : Depois do operando
Prefix - ++n : Antes do operando
Infix - n + n1 : Quando opera entre os dois. Tem um operador uma sintaxe Infix e outro operador.
Unário : Unário Mais + (Unary plus) que converte um operando em um número. Unário Menos - (Unary minus) que converte
um operando em um número e nega o valor depois dele.
. São operandos seguindo uma ordem de precedência assim como na matemática, também valores binários que estão entre ( )
são preferência.
. Operação de modulo - (Resto da divisão) É um valor operando por % 2.

- Operadores: Relacionais.
. É utilizado para realizar comparações, o resultado sempre será verdadeiro ou falso (true or false).
. new Date (0): É uma data de referência do dia 01/01/1970. 
. getTime (): retorna o valor numérico correspondente ao horário da data especificada de acordo com o horário universal.
Operador (==): Este operador é usado para verificar se os dois operandos fornecidos são iguais ou não. 
Operador (===): Este operador é usado para verificar se os dois operandos fornecidos são iguais ou não. Uma comparação 
estrita é válida se os operandos forem do mesmo tipo e se o conteúdo de ambos corresponderem.
Operador (!=): Este operador é usado para verificar se os dois operandos fornecidos são iguais ou não. 
Operador (!==): Retorna verdadeiro caso os operandos não sejam iguais e/ou não sejam do mesmo tipo.
Operador (>): verifica se o primeiro operando é maior que o segundo operando ou não.
Operador (>): verifica se o primeiro operando é maior que o segundo operando ou não.
Operador (>=): verifica se o primeiro operando é maior ou igual ao segundo operando ou não.
Operador (>=): verifica se o primeiro operando é maior ou igual ao segundo operando ou não.
. A melhor com comparação para verificar se os dois operandos fornecidos são iguais é o ===, devido ser uma comparação 
mais precisa, mesmo sendo os mesmos valores a comparação também vale para tipos. Pois poderá haver valores iguais de
diferentes tipos.

- Operadores: Lógicos.
. Uma condição do tipo E, uma coisa tem que acontecer e outra coisa deve acontecer para determinada circunstância 
acontecer. Por exemplo:
    - Eu irei ao mercado, se eu estiver com dinheiro e o tempo estiver bom

. Condição verdadeiro e verdadeiro o resultado será verdadeiro.
. Condição verdadeiro e falso o resultado será falso.
. Condição falso e ? o resultado será falso.
    - Os operandos para serem verdadeiros, todos terá que ser verdadeiro, caso um seja falso, o resultado será falso.

. Uma condição do tipo OU, uma coisa tem que acontecer ou outra deve acontecer para determinada circunstância acontecer
por Exemplo:
    - Eu irei ao mercado, se eu estiver com dinheiro ou estiver com o cartão disponível.

. Condição verdadeiro ou ? o resultado será verdadeiro.
. Condição falso ou ? o resultado será ?.
. Condição verdadeiro ou falso o resultado será verdadeiro.
. Condição falso ou falso o resultado será falso.
    - Os operandos para serem verdadeiros, basta um ser verdadeiro para ter o resultado de verdadeiro.

. Uma condição do tipo OU exclusivo, uma coisa tem que acontecer ou outra não deve acontecer para determinada
circunstância acontecer. Obrigatoriamente os dois devem ser diferentes.

. Condição verdadeiro ou(exclusivo) verdadeiro o resultado será falso.
. Condição falso ou(exclusivo) verdadeiro o resultado será verdadeiro.
. Condição verdadeiro ou(exclusivo) falso o resultado será verdadeiro.
. Condição falso ou(exclusivo) falso o resultado será falso.

. Negação lógica

. Negação verdadeiro -> o resultado será falso
. Negação falso o resultado será verdadeiro.

. Operadores Lógicos em Javascript: 
E ou AND - &&
OU - ||
Negação ou NOT - !

Obs: Exemplos de expressões que podem ser convertidas para falso são aquelas que são avaliados como nulo, 0, 
string vazia ("") ou undefined.

- Operadores: Unários.
. Tente manter códigos simples, e claro para entender. Evite muitos comentários 
. Unário Mais + (Unary plus) que converte um operando em um número.
. Unário Menos - (Unary minus) que converte um operando em um número e nega o valor depois dele.
. Incremento prefixo e sufixo ++ que adiciona um ao seu operando.
. Decremento prefixo e sufixo -- que subtrai um do seu operando.

- Operadores: Ternário.
. Operador ternário possui três partes. Com três valores alternando.
. A primeira parte do operador ternário é uma expressão que irá retornar verdadeiro ou falso.
. É informado o ? 
. Após isso o valor Verdadeiro : o valor Falso;

- Contexto de Execução: Browser vs Node.
. Runtime
. Para execução do Javascript em front-end será no Browser.
. Para execução do Javascript em back-end será no Node.js.

Browser - Console
Window - É um escopo global (objeto).
this - Window
. Quando a variável é declarada com VAR ela irá diretamente para window e quando e declarada com LET e CONST não 
ira para o escopo window.
. Porém não é indicado utilizar o var devido ter como ter acesso e é possível modificar. 
. Uma das formas de não está utilizado o escopo window é utilizando Objetos.
. Todos os arquivos estão em um único arquivo e estão no escopo global.

Node.js - VsCode
this. - É utilizado para exportar o modulo para fora do arquivo
global - Representa o window no nodejs, mas precisa ser declarado.
module.exports. - É a mesma função de this.
. Cada arquivo de dados é um modulo.

- Tratamento de Erro.
. TRY / CATCH / THROW.
TRY - Bloco de código, que informar códigos que possivelmente irão ter erros.
CATCH - É um bloco que analisa o que está dentro do try e dentro dele, é possível tratar o erro ou não.
THROW - É utilizado para lançar o erro com alguma mensagem.
FINALLY - Mostra ao final, tratando ou não o erro. 

Seção 5 JavaScript: Estruturas de Controle.

- Visão Geral do Capítulo.
. Terá a continuidade de Fundamentos, bases de controle.

- Usando a Estrutura IF #01.
. Quando tem um bloco de código, como a função e tem sentencia de código, ele executa a primeira, a segunda e assim
sucessivamente.
. Com a estrutura de controle é possível selecionar uma determinada sentencia de códigos a ser executada, se uma
condição for verdeira ou não, terá resultados diferentes.
. Pode ser passado valores Boolean ou não dentro de If, e ele irá converter se for verdadeiro ou não.

- Usando a Estrutura IF #02.
. O uso da definição de bloco { }, é opcional, dentro de uma estrutura IF, sendo que fica uma sentença de código
associada ao bloco IF.
. Caso queria colocar outras sentenças dentro de um mesmo bloco insira {}.
. Não utilize ; na definição de IF.

- Usando a Estrutura IF/ELSE.
. A condicional IF é uma estrutura condicional que executa a afirmação, dentro do bloco, se determinada condição for 
verdadeira. 
. Se for falsa, executa as afirmações dentro de else.
. Se tiver uma única sentença é possível usa-lo apenas com uma chave, caso tenha mais de uma sentença é obrigatório o
uso de {}.

- Usando a Estrutura IF/ELSE IF...
. É uma maneira de encadear escolhas/resultados extras ao if...else usando 
else if.
. Cada escolha extra requer um bloco adicional para colocar entre if() {...} e else {...}

- Usando a Estrutura SWITCH.
. SWITCH é uma seleção múltipla, não é uma expressão relacional que retorna 
verdadeiro ou falso.
. Existem certas restrições em Javascript.
. A condicional SWITCH avalia uma expressão, combinando o valor da expressão para um cláusula CASE, e executa as 
instruções associadas ao CASE.
. O BREAK associa com cada CASE e garante que o programa saia da condicional, assim que a instrução correspondente 
for executada e executa a instrução que segue logo após o SWITCH.
. Caso não tenha o BREAK, o programa continuará a execução de todas as outras sentenças. 

- Usando a Estrutura WHILE.
. É uma estrutura de repetição, mais apropriada para uma quantidade indeterminada de condições, baseada em uma expressão
verdadeira ou falsa, enquanto for verdadeiro continuará executando, quando estiver falso sairá do laço de repetição.
. Executando nenhuma vez, ou em uma indeterminada quantidade de vezes.
. While precisa de uma expressão que retorne um valor verdadeiro ou falso. Caso ao contrário o laço ficará infinito.

- Usando a Estrutura DO/WHILE.
. É uma variante da estrutura While.
. É invertido a lógica do while, garantindo que uma vez haja repetição dentro do laço.
. Não é uma estrutura muito usada.

- Diferenças na estrutura WHILE e DO/WHILE.
. Arquivo pdf. 

- Usando a Estrutura FOR.
. É a criação de um loop que consiste em três expressões opcionais, dentro de parênteses e separadas por ponto e vírgula,
seguidas por uma declaração ou uma sequência de declarações executadas em sequência.
. A sintaxe do FOR é com a inicialização: Uma expressão ou declaração de váriaveis. Geralmente usada para iniciar o 
contador de variáveis. 
OBS: Esta expressão pode, opcionalmente, declarar novas variáveis com a palavra chave var. Essas variáveis não são
locais no loop, isto é, elas estão no mesmo escopo que o loop for está. Variáveis declaradas com let são locais para
a declaração.
. Condição: É uma expressão para ser avaliada antes de cada interação do loop.
OBS: Se esta expressão for avaliada para true, declaração será executado. Este teste da condição é opcional. 
Se omitido, a condição sempre será avaliada como verdadeira. Se a expressão for avaliada como falsa, a execução 
irá para a primeira expressão após a construção loop for.
. Expressão final: Será validada no final de cada interação do loop.
OBS: Isso ocorre antes da próxima avaliação da condição. Geralmente usado para atualizar ou incrementar a variável 
do contador.
. Declaração: Uma declaração que é executada enquanto a condição for verdadeira. Para executar múltiplas condições
dentro do loop, use uma instrução de bloco ({...}) para agrupar essas condições. Para não executar declarações dentro 
do loop, use uma instrução vazia (;).

- Usando a Estrutura FOR/IN.
. Um exemplo de percorrer um array e um objeto. 
. Interage sobre propriedades enumeradas de um objeto, na ordem original de inserção. O laço pode ser executado para 
cada propriedade distinta do objeto.
. FOR/IN não deve ser usado para iteração em uma Array onde a ordem é importante, visto que ele iterage em uma ordem 
arbitrária.

- Usando BREAK/CONTINUE.
. Break causa um desvio de fluxo, por exemplo: Quando um SWITCH entrava em um CASE e encontrava um BREAK ele 
automaticamente desviava o fluxo para depois do SWITCH. Ele não influencia em um bloco tipo IF. Apenas em um bloco
SWITCH, FOR, WHILE.
. Continue também causa um desvio de fluxo, influenciando apenas no laço FOR e WHILE.
. O Break não age em cima de um bloco IF, então ele age em cima do for, switch ou while. 
. O Continue irá interromper a repetição atual, e ir para seguinte repetição.

Seção 6: JavaScript: Função.

- Cidadão de Primeira Linha. 
. MDN: Funções são blocos de construção fundamentais em Javascript. Uma função 
é um procedimento de Javascript - um conjunto de instruções que executa uma 
tarefa ou calcula um valor. Para usar uma função, você deve defini-la em algum 
lugar no escopo do qual você quiser chamá-la.
// Função em JS First-Class Object (Citizens).
// Higher-order function. - Função de alta ordem 
. Higher-order function. - Função de alta ordem é um dos pilares de uma 
programação funcional.
. Função pode ser tratado como um dado.
. É possível criar uma função armazenada dentro de uma variável ou constante.  
. É possível ser feita uma função dentro de outra função. E também passar um 
parêmetro como função, e é possível retonar uma função.
. É possível armazenar uma função em um atributo de um objeto.
. É possível armazenar uma função dentro de um array. Podendo inserir de forma 
direta ou de forma indireta. Podendo declarar a função na construção do array 
(Não é muito utilizado mas é uma das formas de declarar uma função.). 
. Na criação de uma função é utilizado o function, a função deverá receber um 
nome, pode receber parêmetros e retonar valores, o valor para retorno é 
opcional. Caso seja uma função sem retorno o resultado será undefined.
. O parâmetro será dentro do (). 
. Terá sempre que abrir { } para abertura de bloco. 

- Parâmetros e Retornos são opcionais.
. Exemplo em JS.
. No Javascript permite funções omitir parâmetros. Não há sintaxe em JS que 
específica que um parâmetro é opcional (ou obrigatório). Tudo que está nos 
parâmetros é opcional. Se eles não forem especificados, eles são indefinidos.
. MDN: Em Javascript, parâmetros padrões de funções são undefined. No entanto, 
em algumas situações pode ser útil definir um valor padrão diferente. Isto é 
onde os parâmetros padrão podem ajudar.
. Podendo ser passado quantos quiser, limitando e esquecendo dos outros. 
declarados depois

- Parâmetros Variáveis.
arguments: O objeto arguments é uma variável local disponível dentro de todas 
as funções. Podendo referenciar os argumentos de uma função dentro da função 
usando o objeto arguments.

- Parâmetros Padrão.
. É um recurso adicionado no ES2015. 
. Exemplo em JS antes e depois do ES2015.
. É uma forma mais reduzida, que faz a forma ser mais adequada para escrever. 
. No passado, a estratégia geral para definir padrões era testar os valores de 
parâmetro no corpo da função e atribuir um valor se eles fossem undefined.
. Os parâmetros predefinidos de uma função permitem que parâmetros regulares 
sejam inicializados com com valores iniciais caso undefined ou nenhum valor 
seja passado.

- "THIS" pode variar.
. THIS ou SELF - É uma forma de referenciar um objeto atual de uma função.
. Podendo variar dependendo de como será mencionado. 
. A palavra-chave THIS comporta-se um pouco diferente em Javascript se comparado
com outras linguagens. Também possui algumas diferenças entre o modo estrito e o modo não estrito.
. No contexto de execução global (fora de qualquer função), THIS refere-se ao objeto global, seja em modo estrito ou não.
. O valor de THIS não é definido pela chamada. Por padrão, THIS será o objeto global que no navegador é o window.

- "THIS" e a Função Bind #01.
. Em muitos casos, o valor THIS é determinado pela forma como a função é chamada. Ele não pode ser mencionado durante 
a execução, e isso pode ser diferente a cada vez que a função é chamada. ES5 introduziu o método BIND para estabelecer
o valor THIS da função, independentemente de como ela seja chamada.
. THIS é lexicalmente delimitado (o valor this é estabelecido segundo o escopo de execução no qual está inserido).
. Dentro de uma função, o valor de this depende de como a função é chamada.
. Em modo estrito, o valor de THIS permanece seja qual for o definido ao entrar no contexto de execução, THIS
por padrão será indefinido (undefined).
. Quando uma função é chamada como um método de um objeto, THIS toma o valor do objeto pertencente ao método chamado.
. Onde o THIS ocorrer na função original, na nova função ele será permanentemente ligado ao primeiro argumento de bind,
independentemente de como a função esteja sendo usada.

- "THIS" e a Função Bind #02.
setInterval: É uma função que dispara outra função mencionada dentro de () a partir de um determinado intervalo 
também mencionado no corpo do setInterval.
. Duas possibilidades de fixar o valor do THIS, como o BIND visto na aula passada, ou criando uma constante, por exemplo:
    const self = this;
. E partir dessa constante é possível acessar os atributos desse THIS.

- Função Arrow #01.
. É um novo tipo de função que possui dois objetivo:
. O primeiro objetivo é ser mais curta, tendo uma sintaxe mais reduzida.
. O segundo objetivo é ter um THIS associado ao contexto a qual a função foi escrita. 
. É um tipo de função que fica anônima, então para mencionar ela ao final, terá que armazenar em uma variável ou constante.
. É possível trabalhar com essa função sem o corpo dela sem as {}. Que causará um retorno implícito, ou seja, para funções 
de uma única linha, para um único trabalho. 

- Função Arrow #02.
. THIS dentro de uma função arrow é fixo, baseado no contexto no qual a função foi escrita, e não é influenciado, mesmo
que a função seja chamada de locais diferentes, não altera e nem influencia o valor do THIS.

- Função Arrow #03.
. No caso do NODE cada arquivo representa um módulo. 
. Caso o THIS seja mencionado em um escopo de função normal o resultado será que o THIS é um escopo global, caso seja em 
uma função Arrow o escopo não será global.
. Na função arrow o THIS aponta o objeto para o módulo mencionado.
. Mesmo com o BIND, o contexto do THIS em Arrow não mudará. 

- Funções Anônimas.
. Uma função Anônima é uma função sem o nome. 
. É possível passar uma função anônima em uma função já nomeada, dentro dos parâmetros, ao final, quando é chamada
a função - Exemplo no JS. 
. Outra forma de ver a função anônima e a função arrow, pois a mesma não possui nome.
. Também tem função anônima quando é criado uma função dentro de um objeto.

- Funções Callback #01.
. Uma Função Callback é uma função passada a outra função, e com um determinado evento acontecer essa função Callback será
retornada, podendo ser retornada uma vez ou várias vezes dependendo do contexto no qual está sendo passado a função externa.
forEach() - É uma função de um array, que passa como parâmetro  para o elemento do array ao qual está percorrendo e o outro 
parâmetro que está na função.
. Então forEach() com Callback será:  Para cada elemento que está dentro do array, ele irá chamar de volta os parâmetros 
da função.
. O evento é um loop, então quando ele encontra um novo elemento no array, ele dispara um evento, que será a função
a qual foi incrementada o Callback.

- Funções Callback #02.
. A diferença com o Callback e sem o Callback. - Exemplo em JS.
.filter() - É uma função que irá filtrar os elementos de um array, em cima de um determinado critério, é uma função
do callback que irá retornar true ou false, se a função retornar true, significa que o elemento será adicionado ao 
array que está sendo gerado, se for retornado false não será adicionado o elemento.

- Funções Callback #03. 
. Callback dentro do Browser (Repositório em JS).
. Ao atribuir o callback, ela será resgistrada, e só será executada quando o evento acontecer.
. forEach() - Será também o armazenar, o registrar do callback. (código, sem utilizar o Browser).

- Funções Construtoras
. Funções contrutoras em JS, são como classes do Java, diferenciando apenas pela sintaxe.
. Tanto as funções contrutoras em JS quanto as Classes no Java têm a mesma utilidade: servir de molde para criação de 
objetos.
. Para serem feitos os objetos, funções construtoras precisam ser instanciadas pelo operador NEW.
. O THIS, será para referenciar ao objeto criado a partir delas.
. A diferença entre criar objetos usando funções contrutoras em Javascript, é que os mesmos seguirão com o molde definido
pela função, recebendo seus atributos e métodos.

- Tipos de Declarações.
. Function Declaration: Função criada com uma declaração Function é um objeto e tem todas as propriedades, métodos e 
comportamentos dos objetos. Podendo ser chamada a qualquer parte do código, mesmo sendo declarada depois. 
. Function Expression: É muito similiar e tem quase a mesma sintaxe de uma declaração de função, a principal diferença
entre a Function Declaration e Expression é o nome ao qual pode ser omitido em expressões de funções para criar funções 
Anônimas.
. Named Function Expression: É a mesma função Expression, porém contendo um nome, será declarada através de uma constante
ou de uma variável. 

- Contexto Léxico.
. É muito importante no caso de função, pois ela irá executar conforme o contexto a qual ela foi escrita.
. Exemplo em JS.
. O local onde é declarado as váriaveis é muito importante para o acesso e execução de uma função.

- Closures.
. É o escopo criado quando uma Função é declarada.
. Esse escopo permite que a função acesse e manipule as variáveis externas à função.

- Função Factory #01.
. É uma função que é possível a criação de objetos.
. Funcionando como uma fábrica de objetos, a função retornar um novo objeto sem a utilização da palavra-chave NEW.
. Os métodos são criados no próprio objeto dentro da função.
. Oferece uma melhoria de performace em casos de instanciação de um elevado número de objetos em uma mesma função.

- Function Factory #02.
. Criado dois Exemplos em JS.
. Review da aula passada. 

- Classe vs Função Factory.
. Classe é uma forma diferente de ser criada uma função no Javascript.
. Sendo utilizada para orientação a objetos em Java. Na classe é possível ter atributos e comportamentos diferentes. 
. Em javascript, a classe é uma estrutura utilizada para fazer uma função. Então seria uma função escrita diferente.
. Desafio em JS.

- Desafio Função Construtora.
. Desafio em Js.
. É possível criar um objeto a partir de uma função construtora, a partir de uma função Factory ou de uma classe.

- IIFE. 
. Função autoenvocada, declarada sem nome (anônima), que é executada assim que definida. 
. MDN: É um Self-Executing Anonymous Function e contém duas partes principais. 
. A primeira é a função anônima cujo escopo léxico é feito entre parênteses. Isso previne o acesso externo às variáveis
declaradas na IIFE, bem como evita que estas variáveis locais poluam o escopo global.
. A segunda parte corresponde à criação da expressão (), por meio da qual o interpretador Javascript avaliará e executará
a função.
. A função se torna uma expressão que é imediatamente executada. A variável definida dentro da expressão não pode ser 
acessada fora de seu escopo. 
. Atribuir uma IIFE a uma variável não armazenará a função em si, mas o resultado da função.

- Call & Apply.
. Os métodos Call e Apply facilitam que você escreva um método e componha outros objetos, 
. É uma característica específica do Javascript que proporciona emprestar um método, onde pode ser definido uma função
atribuída ao escopo global mesmo sem ter um objeto ou classe escrita.
. Mas só é possível se for declarado em um outro escopo global.
. A diferença entre o Call e o Apply, é que :
Apply: invoca uma função com o this e um array com os parâmetros da função.
Call: utiliza como o primeiro parâmetro o this e os próximos parâmetros são os da função.

- Comparação entre String de números.
. Salvo no OneDrive.

- Lista de Exercícios: Fundamentos, Estruturas de controle e Funções.
. Em Javascript.

Exercícios Javascript
- Bhaskara
Math.sqrt - Retorna a raiz quadrada do número que for determinado a frente.

Seção 7: JavaScript: Objeto.

- Introdução à OO
. Assim como a função Objetos também é muito importante, as estruturas que geram objetos podem ser classe ou funções,
dependendo da linguagem. o Paradigma procedural é baseado no procedimento da função, sendo um trecho de código que possui
um nome e esse nome, é utilizado em outros lugares. Quando é feito uma linguagem procedural o foco é muito forte na função.
. Paradigmas de orientação a objetos, é um tipo de linguagem estruturada.
. Em OO é realizado os dados e dentro dos dados e declarado as funções, então em OO o objeto passa a ser uma figura
central.
. Então em OO, tem o objeto que tem valores ou seja atributos, e tem funções que são os comportamentos. E para chama-los
a partir do dado. 

Principios Importantes: 

1. Abstração: É ter um objeto no mundo real e traduzir para o sistema e que faça sentido ao programar, entendo como mapear
para ter as funções conforme o necessário. 

2. Encapsulamento: São os detalhes de implementação escondidos para mostrar uma interface simples para quem precisa
utilizar o programa para que possa interagir com determinados objetos. (Quando é mudado a implementação interna de um
objeto, não necessariamente quem utiliza aquele objeto precisa se adaptar, somente mudando a interface de comunicação 
aquilo que está visivel fora do objeto irá notar).

3. Herança: Significa que é recebido, atributos e comportamentos de um objeto central, algumas linguagens é possível 
receber multiplas heranças, mas no caso do Javascript é possível somente uma.

4. Polimorfismo: Significa multiplas formas, a partir de uma variavel do tipo mais genérico podendo atribuir outras 
heranças. 

- Revisão sobre Objeto.
. Uma forma de começar um novo objeto é usando o NEW.
. Por ser dinâmico, é possível adicionar anotação com o ponto . , por exemplo:
produto.nome = 'Cadeira'; 
ou adicionar anotação parecida com array usando o colchetes [], por exemplo:
produto['Marca do produto'] = 'Generica';
. Como é possível adicionar dinamicamente, também é possível excluir os atributos de um objeto, utilizando Delete, por
exemplo:
delete produto.preco 
. Pode possuir atributos tipos mais básicos utilizando strings, numbers, mas também é possível acrescentar valores
booleanos e outros tipos básicos da linguagem, Dentro de um objeto, é possível de ter pares chave e valor, com outros
objetos e atributos, arrays conjuntos de objetos ou dados básicos, e também acrescentar funções.
. CUIDADO: Ao deletar qualquer atributo e depois tentar acessar, constará Undefined.

- Estratégias de Criação de Objetos. 
. Formas diferentes de se criar objetos em Js:

Notação Literal: Usando um par de chaves, por exemplo:
const obj1 = {}

Object em JS: Utilizando a forma de criar objetos a partir de uma função construtora, por exemplo: 
console.log(typeof new Object);
E é possível passar os parâmetros a partir de ().

Funções Construtora: A partir de uma função contrutora, por exemplo: 
function produto(nome, preco, desc){
    this.nome = nome;
}
. O THIS, faz com que a variavel se torne pública, e as outras ficam encapsulada, de forma que não poderá ser alterada
externamente, caso seja criado um atributo com encapsulamento, será visivel somente internamente. Então teriam dois modos 
para se deixar: Público ou Privado.
Exemplo de escopos no Browser: Escopos global (window), Escopo da função e Escopo do var e do let ou const. 

. Também é possível criar através de uma Função Factory, através de um Object.create e através de umaa função famosa que
retorna Objeto.

- Objetos Constantes.
Object.freeze() - Congela o objeto, então não é possível apagar e nem alterar os dados do objeto, isso faz com que o 
objeto seja constante. 

- Notação Literal.
. Versão ES2015 - Melhorias. (Exemplo em Js).
. Foram reduzida as formas de inserir dados para um objeto, atribuições com valores Strings e Numbers no mesmo objeto, e criação
de outras funções no mesmo objeto.
. Para inserir valores a um objeto foi reduzida sendo que antigamente seria:
const a = 1;
const b = 2;
const c = 3;
const obj1 = {a: a, b: b, c: c}; 

Depois do ES2015:
const obj2 = {a, b, c};

. Para atribuir Strings e Numbers no mesmo objeto, antigamente seria:
const nomeAttr = 'Nota';
const valorAttr = 7.87;
const obj3 = {}
obj3[nomeAttr] = valorAttr;

Depois do ES2015:
const obj4 = {[nomeAttr]: valorAttr}

. Para criação de funções ou mais de uma função seria: 
const obj5 = { 
    funcao1: function(){
        //Realizar a função.
    },
    funcao2(){
        // Também poderá realizar uma função.
    }
}

. Todas as formas acima é a redução que foi implementada no ES2015, podendo fazer da forma antiga ou da forma mais
atual.

- Getters/Setters
. Técnicas de encapsulamento de um código em uma estrutura como o objetos.
. Ter atributos privados e ter métodos para que esses atributos sejam alterados de uma forma mais controlada. 
. Métodos de Getters/Setters em JS.
. Getters é a leitura de uma variável atribuida.
. Setters é a leitura e alteração de uma variável atribuida.
. Para convencionar uma variável utilize _ , isso fará com que seja visível uma variável que internamente para
quem está fazendo o código.
. Get com uma função faz com que os valores sejam acessados, podendo ser utilizado como validação ou processamento.

Obs: Em JS não é possível fazer o sobrecarregamento de métodos. (Vários métodos com o mesmo nome mas com parâmetros
diferentes.)

- Funções Importantes de Objetos.

Object.keys - Todas as chaves que compoem o Objeto.
Object.values - Todos os valores que está compondo um Objeto.
Object.entries  - Um array externo que compoem um array para cada chave/valor. Podendo utilizar o forEach para 
percorrer o array, por exemplo: Object.entries(pessoa).forEach( e => {});
Object.defineProperty() - Para criar e definir uma propriedade, é possível inserir um objeto para declarar as
características da propriedade, como:
Enumerable: Para listar ou não essa propriedade.
Writable: Para modificar ou não.
Value: Sendo possível atribuir um valor.
Object.assing - Funcionalidade que começou no ECMAScript 2015, é a criação de um objeto com o objetivo de ser o
destino de outros objetos, sendo que todos os objetos declarados após o primeiro será concatenado todos os atributos
no primeiro.
Object.freeze - Congelamento dos dados do objeto, isso faz com que não seja alterado.

- Herança #01.
. É uma característica comum na OO onde uma classe pode herdar comportamentos e características de uma classe 
superior.
.  Metódo herança prototipada: Cada objeto tem um link interno para um outro objeto chamado prototype, quando um
objeto é prototype, os atributos também são.
. Um atributo prototype só estará disponível em uma função.
. Então em JS a herança é definida a partir de uma referência para um protótipo, que possue uma aparência para 
um outro objeto, e esse objeto tem atributos e comportamentos que podem ser acessados pelo próximo objeto a ser
declarado.

- Herança #02.
. Conceito da cadeia de herança na prática.
. Object.prototype - É um objeto podendo ser adicionado atributos e comportamentos dentro do mesmo. Mas não é muito
recomendado. 
. Caso não seja introduzido o valor da herança conforme a cadeia montada, constará Undefined.
Shadowing - Quando possue uma variável privada, mas pode sombrear outras variáveis de escopos mais abrangentes.
${super.status()} - Serve para referenciar o método que está no protótipo no objeto.
super(arguments) - Utilizado para acessar o objeto pai de um objeto, em outros casos é utilizado para acessar a 
classe pai de uma classe.
Object.setPrototypeOf - Uma função para realizar uma relação com o protótipo, e mostrará as funções e atributos que 
pertecem a um objeto.

- Herança #03.
Object.create - É passado o Objeto que irá ser o protótipo do objeto que será criado a partir desse metódo.
. Além de ser informado os outros objetos podem ser definidos atributos, colocando valores e definindo algumas 
propriedades do atributo.
Object.keys - Mostrará a chave de qual valor será informado. 
hasOwnProperty - Utilizado no FOR/IN É uma verificação de propriedade se irá pertecer ou não o objeto que está 
percorrendo.

- Herança #04.
. Função sobre a função e o atributo prototype da função.
. Todos os Objetos criados a partir de uma mesma função construtora, tem o mesmo protótipo, a partir do atributo
__proto__.
. A partir da cadeia de protótipos tem: 
O atributo prototype da função que toda função tem esse atributo.
E o atributo onde o produto que é como um objeto referência.

- Herança #05.
. Funcionalidades de protótipos
. String, Array e Object tem um atributo prototype.
reverse() - Método que inverte os itens de um array, o primeiro elemento do array se torna o último e o último 
torna-se o primeiro.
. Alterar funções que já estão presente em um protótipo ocorrerá um erro.
. Não substituir comportamentos que já existem de forma global para que não cause um grande erro, por conta das APIs
outras funções esperam receber a função padrão da API do JS, então é um risco muito alto para a aplicação.

- Herança #06.
. Teste de simular o operador NEW em uma função.
. Exemplo em JS.

- Evitando Modificações.
. Funções deixando os dados imutáveis, para não estender ou adicionar novos atributos ou remover atributos de 
determinados objetos.
. Restringir é eficaz para que tenha um pouco mais de previsibilidade e para algum tipo de objeto.
Object.preventExtensions - Previne que o Objeto não seja estendido, ou seja não será possível aumentar o número
de atributos, apenas excluir atributos.
Object.isExtensible - Teste para verificar se o Objeto é criado com o Object.preventExtensions.
Object.seal - Não é possível adicionar novos atributos e nem excluir atributos já realizados no Objeto, mas é 
possível modificar os valores. 
Object.freeze - Congelamento dos dados do objeto, isso faz com que não seja alterado.

-  JSON vs Objeto.
. JSON é um formato textual que é diferente da anotação literal de Objetos.
. É um formato de dados, usado no mercado hoje para interoperabilidade (É a capacidade de um sistema de se comunicar
de forma transparente com outro sistema). Tem um formato textual, genérico que não carrega consigo algo específico,
de um sistema, e de alguma tecnologia, por exemplo um formato binário de outras linguagens.  
OBS: Para isso é muito importante que ele trabalhe com padrões abertos.
. É um formato simples de ser lido, e ser interpretado no computador
. Possível fazer a leitura do Json em Java, C#, Ruby, Python, Javascript, em qualquer linguagem antiga.
. Um formato simples e direto Json é amplamente usado para ter a migração de dados entre sistemas, e também como 
leitor dentro do mesmo sistema.
. Utilizado para armazenar configurações internas de um sistema.
JSON.stringify() - Mostrará o formato textual que está no código, sendo um formato de dados, isso fará com que
não receba as funções. 
. Como é seguido um padrão, é possível que outras aplicações utilizem convertendo para objetos.
. Os atributos no formato de JSON devem ser delimitados por aspas duplas, por exemplo:
console.log(JSON.parse('{"a": 1, "b": 2, "c": 3 }')); 
. Possibilidades que o JSON suporta o formato: Json.parse()
Valor númerico: Não é necessário utilizar aspas.
String: Utilizando aspas duplas.
Valores Booleanos: Utilizando aspas duplas ou literalmente.
Objeto: Não é necessário utilizar aspas. // Se houver atributos as strings deverão ter aspas duplas.
Array: Não é necessário utilizar aspas.
Json Validator - Site de indicação.  

- Classe #01
. Na atualização do ECMAScript 2015, surgiu um conceito de classe, sendo possível contruir uma estrutura semelhante 
a uma classe, mas sendo somente um detalhe de sintaxe. 
. Devido a classe ser convertida a uma função.
. OO em Javascript é centrada em funções, podendo criar objetos literais, mas também é possível criar objetos a partir
da instanciação da função. 
constructor() - Para transformar a classe em uma função construtora.
. É uma forma alternativa de realizar funções contrutoras. 
. Pode trazer uma familiaridade de outras linguagens, por exemplo o Java, C#... 

- Classe #02.
. Exemplo em JS, de heranças em classe. 
class Pai extends Avo - É a forma que se tem no âmbito de sintaxe de classe para definir uma determinada classe tem
outra classe como protótipo, ou que determinada função gerada a partir daquela classe terá como protótipo, uma outra
função que será gerada a partir da classe.

Seção 8: JavaScript: Array. 

- Array: Visão Geral.
. Encerramento da base do Javascript.
. Array em JS é um objeto especial, que possui características prórprias mas não existe o nativo em JS, ou tipo de 
dados array.
. Com Objetos os atributos são organizados a partir de chaves identificadoras {}, já utilizando array a forma de 
organizar os atributos é a partir de uma estrutura indexada, começando do zero.
. Então o primeiro elemento que é colocado em um array é o índice zero, o segundo seria o índice um, e assim por
diante. 
. Assim tendo uma organização melhor, para realizar a anotação literal é utilizado colchetes [].
. Sendo uma estrutura dinâmica, crescendo e diminuindo dinamicamente, diferente de outras linguagens em que o array 
possui um tanho fixo.
. Array sendo utilizado em JS que é uma linguagem fracamente tipada, pode receber diferentes tipos de dados, fazendo
com que seja uma estrutura heterogênea. Fazendo isso com que na prática seja possível trabalhar com dados homogêneos 
todos do mesmo tipo dentro de um Array.
. Caso seja acessado um índice que não consta no array, constará undefined.
. Mesmo sendo deletado algum valor, a posição dos outros valores referente ao índice que estão, não será alterado, e
sim constando como undefined.

- Métodos Importantes.
. Funções interessantes do Array. Exemplo em JS.
. A partir do momento que é atribuido o Array em uma constante, não é possível atribuir outros dados na constante
diretamente. 
push() - Para adicionar outros elementos.
pop() - Remove o último elemento.
shift() - Remove o primeiro elemento.
unshift() - É acrescentado um elemento no índice 0. 
slice() - Cria um novo array a partir do índice mencionado entre parênteses.

- Simulando Array com Objeto.
. Objeto simulando um array.
. A partir de um objeto, é possível ter uma estrutura parecida com um Array.

- ForEach #01.
. Formas diferentes de percorrer um Array, ou seja, passar pelos elementos de um Array para fazer algum tipo de 
operação.
. O forEach executa o callback fornecido uma vez para cada elemento da ordem com um valor atribuido.
. Não é invocado apenas para propriedades de índices que foram deletados ou que não foram inicializados.
. O callback é invocado com três argumentos:
O valor do elemento.
O índice do elemento.
O array que está sendo percorrido.
. O intervalo dos elementos processados por forEach() é determinado antes da primeira invocação do callback.
. Elementos que forem adicionados ao array depois da chamada ao forEach() não serão mencionados pelo callback.
. Se os valores dos elementos existentes do array forem alterados, o valor passado para o callback será o valor 
no momento em que o forEach() for mencionado, elementos que forem deletados antes de serem mencionados não serão 
visíveis.
. O forEach() executa a a função callback uma vez para cada elemento do array – diferentemente de map() ou reduce(),
ele sempre retorna o valor undefined e não é encadeável. O caso de uso típico é alterar o array no final do loop.

- ForEach #02.
. Desafio de implementação do foreach().
. Utilizando o Array.prototype, criando uma função foreach que irá ser associada a um parâmetro callback, que terá
um laço for.
. No parâmetro da função chamado callback terá três parâmetros: Valor, índice e o array.
. Isso fará com que a função callback passe o valor atual o índice e percorra o array completo. 

- Map #01.
. No Map é função do Array, associada ao Map existe dentro um laço onde irá ser executado, e também tem a função de 
realizar a transformação em um array.
. Então a função Map tem a ideia de mapear um array para outro array do mesmo tamanho, mas com os dados transformados.
. A regra do map é simples, caso tenha um array com seis elementos, após o map terá o outro array transformado com
seis elementos também. 
. No caso do Map, para criação, internamente terá um for, além do for ele terá uma transformação.
map() - receberá pares de chave-valor e lembra a ordem original da inserção das chaves. (Qualquer valor (objetos e 
valores primitivos) podem ser usados como chave ou valor.)

- Map #02.
. Desafio em JS. 
. Retornar array apenas com os preços. 
. Utilizando o método Json, e map(). 

- Map #03.
. Implementação do Map, utilizando o Array.prototype.
. Após usar a função Array.prototype é feita uma função com os parâmetros para implementação:
A criação de um Array vazio.
O Laço for com o this para percorrer o Array original. 
Dentro da função callback, com o valor o índice, transformação do array e o array original . 
Resultado da callback é o retorno do array criado acima.
. Então essa seria a forma do funcionamento do map internamente. 

- Filter #01.
. Filter serve para filtrar o Array, sobre a quantidade de elementos menores baseados em algum critério de filtro.
.filter() - É uma função que irá filtrar os elementos de um array, em cima de um determinado critério.
. Então o conceito do Filter é uma função callback que retorna verdadeiro ou falso, recebendo um item atual, o índice
atual e o array que está percorrendo, e caso seja verdadeiro o array terá o elemento, caso seja falso não terá o
elemento.

- Filter #02.
. Implementação do Filter, utilizando o Array.prototype.
. Usando o exemplo do exercício da aula Filter #01.
. Ao criar uma função com o método Array.prototype, com o parâmetro de callback.
Criar uma constante para um novo array.
Laço for para percorrer o array original.
Usar a estrutura If com o parâmetro callback para que caso o elemento que esteja no original for true, retorne no
novo Array vazio. 
Retornando o novo Array com os resultados do Filter. 

- Reduce #01.
. Uma função que serve para transformar um array em um único elemento, ou em um array, ou em um objeto ou em uma 
string, depedendo do critério que for colocado.
. Também é utilizado para agregar em um único valor ou array, então é possível reduzir e agregar os valores em somente
um.
. Terá um parâmetro que ira ser acumulado para cada chamada que for mencionado, e o resultado do Reduce será 
sempre passado para próxima interação.
. Por exemplo, caso tenha um elemento e utilize o reduce, terá esse acumulador que é o valor que é passado
como resposta da função anterior para a próxima. 
. A função reducer recebe quatro parâmetros:
Acumulador - Valor inicial (ou o valor do callback anterior).
ValorAtual - O valor do elemento atual.
Index - O índice atual.
Array - O array onde a iteração está ocorrendo.
. O valor de retorno da sua função reducer é atribuída ao acumulador. O acumulador, com seu valor atualizado, 
é repassado para cada iteração subsequente pelo array, que por fim, se tornará o valor resultante, único, final.

- Reduce #02.
. Desafio em JS para utilizar o MAP e REDUCE.

- Reduce #03.
. Implementação do Reduce, utilizando o Array.prototype.
Array.prototype.reduce2 = function(callback){
    let acumulador = this[0];
    for(let i = 1; i < this.length; i++){
        acumulador = callback(acumulador, this[i], i, this)
    }
    return acumulador;
}

. Para implementação do reduce é utilizado uma função com um parâmetro callback que terá uma variável acumuladora,
que receberá um índice, após isso é aberto um laço de repetição for para percorrer o array atual, complementando com 
o acumulador que receberá o parâmetro do callback que terá o acumulador, o index, o valor do elemento atual e o array
percorrido.
OBS: Se o valorInicial não tiver sido passado como argumento, então reduce() executará o callback da função começando
a partir do índice 1 (index 1), pulando o primeiro índice (index 0). Se o valorInicial for passado como argumento, a
função irá começar no index 0.

- Imperativo VS Declarativo.
. Diferenças e conceito da criação de um código Imperativo para um código Declarativo.
. Exemplo de diferenciação em JS.
Imperativo
. Seria uma forma mais de detalhada, o mais importante do imperativo é como deve ser feito os detalhes internos,
e não o que tem que ser feito. 
Declarativo.
. Já a o declarativo o foco é do que tem que ser feito, não focado em detalhes internos, na estrutura criada
declarativa é passado o critério daquilo que de fato deve ser executado no momento em que for agregadando os valores 
e atributos.

- Concat.
. Método para concatenar vários arrays em um único array, ou vários elementos passados como parâmetros para um método
concat e todos os elementos serão concatenados em um outro array.
concat() - É a função da concatenação entre arrays, por exemplo:
const filhas = ['Maria', 'Ana'];
const filhos = ['José', 'Marcio'];
const todos = filhas.concat(filhos, 'Pedro');
. Entre parênteses é possível acrescentar outro elemento para constar no array.
. É possível acrescentar também um array vazio, acrescentando os dados a partir do array ou elemento seguinte. 

- FlatMap.
. Um método que mapeia cada elemento usando uma função de mapeamento e, em seguida, nivela o resultado em um novo 
array. É idêntico a um map seguido por um flat, mas flatMap é bastante útil e mescla ambos em um método um pouco
mais eficiente.

Seção 9: Lista de Exercícios de JavaScript.

. Exercícios para finalização do conteúdo de JS.

Seção 10: Node. 

- Node: Visão Geral.
. NodeJS, é extremamente importante para revolução do Javascript, trazendo a resulução de back-end ser contruido 
em Javascript.
. É possível criar e executar sistemas inteiros usando Javascript, não só a parte clássica do front-end, mas também
executando código diretamente no servidor direto no back-end.
. O fato é que é possível realizar uma arquitetura cliente servidor e o cliente seria o Browser executando a página,
e tendo um servidor que provê por exemplo as APIs, acesso aos bancos de dados, ultizando uma ou mais soluções, criando
assim essa estrutura de cliente e servidor, front-end rodando no browser e o back-end que podendo rodar diversas 
linguagens. 
. O principal runtime do Javascript no back-end é o Node.
. No Node é utilizado o mesmo interpretador do Chrome que no caso é o V8, e essa mesma engine de interpretação do
javascript que roda no browser, também roda no node.
. Então em resumo, o Node é o ambiente de execução do Javascript do lado do servidor, então não está rodando dentro 
do browser. 
. O node foi fundado em 2009, por Ryan Dahl.
Ryan começou a comparar dois grandes web server que na época era o Apache e Nginx
Apache era um servidor baseado em thread, cada requisição que chega no apache é criado uma thread para tratar 
aquela requisição.
Nginx é um único processo master que fica executando e quando chega alguma requisição, é despachado e fica a thread
principal, despachando e tratando as requisições que entra.
. Nginx conforme entra as conexões tem uma queda, mas assim que estabiliza com várias conexões ele se mantém estável,
diferente do Apache que conforme as conexões aumentam o servidor tem uma queda na qualidade. 
. Na questão de memória, quanto mais acesso, mais trade aberto, entrega e procesamento, o Apache tem um consumo maior,
diferente do Nginx que é estável também a questão de memória. 
. Nginx foi uma das arquiteturas que Ryan se inspirou para realizar a criação do NodeJs.
. Possuindo uma estrutura contendo um processo Master que mostra e recebe as aquisições e passa para cada workers,
que faz a parte manipulação da requisição, ou acessa a um banco de dados, que possuem diversos I/O.
. O Node inicialmente não foi criado para ser uma plataforma de back-end para javascript, na verdade ele foi criado 
para fazer a parte de I/O mais correta possível. 
. O javascript veio como consequência por conta de ser uma linguagem propriamente preparada podendo ser trabalhada 
assíncrona, então o javascript foi escolhido para trabalhar com o Node. 

Aplicação                      Node.JS
    |                          Bindings    
JavaScript                    (Node API)
    |                          
    V8             --------  OS Operation   
(JavaScript Engine)                |     
                                   |
                                LIBUV
                             (Asynchronous I/O)

        Event Queue ------>    Event Loop  ------> Blocking Operation 
              |                                        |
              |                                        |   
              ------------- Execute Callback  <---- Workers Thread

. Então essa seria uma forma de mostrar a interligação do mundo Javascript interpretado passando para o LIBUV e V8,
o V8 seria o interpretador para leitura de código em javascript e partir da leitura será feito as chamadas e será
utilizado o LIBUV, escrita em C, e fazendo com que todo o assíncrona do Node. 
. Dentro do LIBUV que é o responsável por fazer toda parte I/O assíncrona. 
I/O: É ultizado para leitura de arquivo, acesso a banco de dados e conexões com a rede. 
. Quando é acessado o banco de dados é feito um I/O, para acessar o disco, arquivo, mandar requisição pela rede. 
Então qualquer coisa que envolva entrada e saída. 
. Devido ter várias funções o I/O tem o Event Loop que recebe as requisições, mono thread. Se for feito um processo
pesado dentro do event loop, causará uma pausa e a próxima requisição só será atendida quando o Event estiver livre.
. O ideal é que não seja feito nenhum processamento pesado dentro do Event Loop, para não pausar as requisições,
onde as thread de fato realizam o trabalho de acessar disco, banco de dados... Algo que demanda tempo de espera e
assim que a ação for terminada, será executado um callback e resposta será enviada. 
. Então o Event Loop é o que recebe em uma única thread que fica despachando para I/O realizar de uma forma assíncrona.
. Sendo possível ter mais de uma thread caso seja um processamento maior, dependendo da quantidade de processadores que
possua na máquina.
. Resumindo o NodeJS é runtime do Javascript, formado por duas partes V8 que é um interpretador JavaScript e de 
código aberto do Google + LIBUV que é o que trata de forma assíncrona a parte mais lenta do processo, tudo que se 
diz respeito ao I/O.

- Sistema de Módulos. 
. Conceito muito importante, como entender uma aplicação é organizada, utilizando um projeto arquitetural chamado
Layers que a aplicação é dívidida em camadas
. Um exemplo sobre Layers é o padrão de camadas do protocolo TCP IP. Tendo a camada física, camada de enlace, camada 
de redes, transporte e com isso é organizado esse software que é o protocolo em camadas, fazendo com que cada camada
faça a sua responsabilidade. 
. É diferente a forma que é organizada uma aplicação no front-end da forma que é feita a organização no back-end
usando o runtime Node.
. No Front-end a aplicação moderna escrita em Javascript usando frameworks, é composta por vários arquivos, sendo
feita uma concatenação todos os arquivos em um único arquivo ou em poucos arquivos, para subir para produção, para 
ser transmitido melhor no browser, fazendo com que o site ou página fique menos pesada, e esse arquivo vai ser lido
diretamente no browser. 
. No caso do Back-end também é organizada a aplicação em pastas e arquivos, mas não é necessário compactar em um
único arquivo, pois não irá para o browser, será executado diretamente no servidor. 
. Se caso seja enviado algum arquivo para um sistema web, normalmente é enviado com o formato de arquivo Json.
. Dentro do Node, um arquivo representa um módulo. (Exemplo em JS).
. Usando o node como servidor, podendo ser como um servidor web que provê um arquivo, imagem, vídeo, gerar
conteúdo dinâmico, e também pode servir como API do sistema. 
. É organizado uma aplicação Back-end em pastas e arquivos e cada arquivo representa um módulo.
. Um módulo tem uma certa interioridade, não ficando disponível para todo mundo, tendo a prioridade de que tudo que 
é escrito ficando visível apenas dentro do módulo. 
. Para criação de um arquivo node e torna-lo público, é preciso exportar algo, e importar algo dentro de outro 
arquivo. É ultilizado dois modos, o CommonJs, que é o padrão mais utilizado, e o padrão do ECMAScript 2015 que é o 
import e export. 
. Para exportação de arquivos é utilizado:
module.exports = { } - Forma clássica de exportação de arquivos, e também a forma de atribuir novos atributos no módulo.
this. - Referência utilizada para o Module.exports
exports. - Forma mais utilizada para exportação.
module.exports. - Forma de exportação
. Para acessar os módulos será feito um arquivo .cliente , onde será visível mais de um arquivo que foi criado, para
mencionar no arquivo é utilizado:
require('../ ) - Onde é mencionado o arquivo para ser importado.
. No exemplo foi utilizado o sistema de módulos no Node o CommonJs, apenas o que é exportado para fora, será 
visível, e o restante do código criado ficará apenas internamente visível.

- Usando Módulos de Terceiros.
. Como exportar módulos de terceiros e utilizar dentro do próprio sistema.
Git ignore - Utilizado no arquivo VS para não ir para o repositório a pasta ou arquivo mencionado.  
_ - Ter acesso ou referenciar um arquivo.
Nodemon - Uma biblioteca que auxilia no desenvolvimento do código, então assim que o código executado, sempre 
mostrará a versão mais atualizada do mesmo.

- Sistema de Módulos: Require.
. Função require, utilizado para importar módulos em node, permitindo também que seja 
importado pastas, arquivos e projetos em outras extensões. 
. Para mencionar as pastas no require é utilizado: ../ , e sempre respeitando as letras maiúsculas e minúsculas para
mencionar o módulo.
. Mencionar a pasta também de forma extensa é possível mas não é viável pois pode ocorrer alterações de pastas e 
maquinas distintas. 
. Também é possível importar os módulos que estão disponiveís no node_modules e os que vem previamente instalados com
o node.
. Finalizando, a criação do index dentro de uma pasta, mencionando outros arquivos para quando for utilizado o
require com o index é realizado uma junção de todos os arquivos mencionados no index. 

- Sistema de Módulos: Exports.
. Função de exportação de módulos e arquivos.
. Para realizar exportações, tem três maneiras possíveis.
this. - Referência utilizada para o Module.exports
exports. - Forma resumida para exportar. 
module.exports. - Forma mais utilizada para exportação.
. Mesmo que seja alterado o as outras maneiras de exportação, a opção module.exports retonará sem alterações.
. Sempre que for necessário atribuir um novo objeto a ser exportado, terá que ser através do module.exports = { }.

- Arquivo package.json.
. Arquivo descritor de um projeto em Node.
npm init - Comando para habilitar e definir como será o arquivo package.json
. Outra forma de ser criada é utilizando: npm init -y , que resultará em todas as perguntas a resposta sim e criará
o arquivo package.json.
. Além de descrever o projeto, o grande objetivo é descrever também todas as dependência que o projeto precisa. 
--save - Isso fará com que salve as dependências ao instala-las no terminal.
npm i --save-dev dependência@versão - Permitirá que seja instalado a dependência com a versão que for escolhida.
. O arquivo package-lock.json - Será o arquivo que grava a exata versão instalada de cada dependência ou pacote 
instalado, e o npm irá utilizar essas exatas versões quando executar. 
. Desafio utilizando url do curso.

- Resolvendo Desafio.
. Resolvedo o Desafio com filtros dentro da url de funcionários disponivel na aula passada.
. Criando funções para filtrar: Todos os chineses, todas as mulheres chinesas e com o menor salário.

- Instância Única vs Nova Instância.
. Como é realizado cache sobre os módulos importados devido a função require. 
. Por padrão do Node, cada módulo que é importado, será cacheado.
. A função factory retorna uma nova instancia. Então o rescurso de função Factory é ultilizado para não ocorrer o 
cache, e sempre que for importado o módulo gerará um novo objeto. 
require('../ ')() - Para executar uma função factory dentro de um módulo importado.
inc - Incrementação sobre o valor.

- Objeto Global do Node.
. Assim como no Browser, o Node também possui um objeto global, sendo que no browser o objeto global é o window, no
Node será global.
. Lembrando que um objeto global é um objeto que pode ser acessado em qualquer lugar da aplicação, independente do 
arquivo, então ao realizar alterações em um objeto global, as chances de ocorrer erros nas aplicações é maior. 
. Para isso o Node possui um sistema de módulos para que resolva esses erros causados. 
. Para cada classe ou módulo que for declarado como global qualquer outro arquivo terá acesso.
globalThis. - Forma de declarar o objeto global.
. Para evitar que seja alterado um valor declarado global, é possível utilizar o Object.freeze.

- Entendendo o 'this'.
. O this refere-se ao module.exports.
. Diferenças do this ocorre na forma de como é acessado.
. Se estiver acessando o this dentro de uma função, será a forma que acessará a parte global.
. Caso seja acessado dentro do modulo, será o acessado o module.exports. Ou seja será transformado algo global, que
será visível fora do módulo.

- This em Arrow Function.
. This em arrow functions, não é possível ter acesso ao "this convencional".
. Enquanto em funções tradicionais possuem seu "próprio this". Ao declarar this em uma função arrow é que será
encontrado o this do objeto global.

- Passando Parâmetros entre Módulos.
. Caso módulo retorne uma função é possível que seja passado um parâmetro para execução dessa função.
. É necessário que tenha uma função ao módulo que for exportado, e assim que for declarado o módulo passar os Parâmetros
entre os parênteses a frente. Por exemplo:
const saudacoes = require('../Node/passandoParametro')('Ana', 'Lucas', 'João')

- Instalando Deps & Scripts.
. Como modificar o arquivo package.Json, recriando a pasta node_modules.
Main - Comando que refere-se será o arquivo principal.
. Na área Scripts, sendo possível definir alguns scripts comandos para executar dentro da aplicação, sendo alguns
pré definidos pelo node.
npm i - Será utilizado para instalar as dependências necessárias para aplicação, e recriação da pasta node_modules
npm run - Para executar scripts definidos manualmente.
Start - Executará a dependência informada a partir do momento que for executado o arquivo ou módulo, monitorando o 
arquivo, caso ocorra alterações, será ajustado e executará com a versão atualizada.
Dev - Terá a mesma funcionalidade do start.
. Concluindo, a área de Scripts no package.json, serve para definir comandos, e comandos encadeados, gerar arquivos
para a produção, switch de teste, tarefas automatizadas, que facilitará para o desenvolvimento da aplicação.

- Lendo Arquivos.
. Como realizar leitura, e escritura de arquivos ao lado do servidor.
. Dentro da própria instalação do Node, possui alguns modulos, e um desses módulos é o File System (FS), responsável 
por ler e escrever e verificar conteúdos dentro de pastas.
const fs = require('fs'). - Para acessar o módulo do próprio node. Será procurado dentro dos módulos nativos do
próprio node, caso não encontre será procurado dentro de node_modules. 
. Ler um arquivo de forma síncrona pode não ser muito indicado, lembrando que se for algum arquivo pesado, ocorrerá 
que uma grande demora de leitura devido o arquivo ser grande, principalmente com arquivos I/O, leitura e escrita de
arquivo, acesso a alguma requisição remota, mandar alguma requisição para o banco de dados. Isso envolve uma questão 
de tempo de reposta consideravel, e ira travar o Event-Loop.
require('../') - Leitura do arquivo em Json e converterá o arquivo em objeto.
fs.readFileSync() - Leitura de um arquivo de forma síncrona.
fs.readFile() - Leitura de um arquivo de forma assíncrona.
fs.readdir(__dirname (callback)) - Leitura do diretório, e com o callback mostrará todos os arquivos que a mesma
contém.
__dirname - É utilizado para obter o nome do arquivo ou o nome do diretório do arquivo atualmente em execução.

- Escrevendo Arquivos.
. Podendo ser gravado dados em um arquivo JSON utilizando o fs.writeFile.
fs.writeFile - É utilizado para gravar de forma assíncrona os dados especificados em um arquivo. Por padrão, o 
arquivo seria substituído se existir. 
JSON.stringify() - Método para converter string em arquivo JSON.

- Frameworks Web.
. Conceito importante de framework web, que possibilita para criação de web server.
. Construção de web server utilizando express.
. Existe divisão entre o código que executa no servidor (back-end) e o código que é interpretado pelo browser que é o 
(front-end).
. Um framework é uma estrutura para a aplicação, possui uma base para que possa desenvolver a aplicação seguindo 
a arquitetura, os preceitos ou mesmo as configurações que o framework estabelece.
Exemplos de framework e bibliotecas:
Angula - Framework              jQuery - Biblioteca
Vue.js - Framework              React.js - Biblioteca
. O Express.js é um framework, que auxiliará na construção de web server ao lado do back-end. Que facilitará a mapear
banco de dados, persistir os dados do banco de dados.

- Padrão Middleware #01.
. O padrão GOF tem a propósito de separar um processo em pequenos passos, mas a lógica do próximo passo não há uma 
junção específica
. Padrão Chain of Responsibility - É um padrão de projeto comportamental que permite passar a solicitação ao longo
da sequência de passos em potencial até que um deles lide com a solicitação.
. O Express é baseado no padrão GOF
. Com o Middleware, o desenvolvimento pode criar aplicações com mais facilidade e eficiência, pois esse tipo de 
software tem o papel de conectar aplicações, dados e usuários. 
. É possível trocar a sequência dos passos, porque, após a sua função ser declarada como parâmetro será acrescentado 
next() - Função responsável por executar a próxima função. 

- Padrão Middleware #02.
. Utilizando o padrão GOF, é uma forma de comunicar os dados de uma função para outra, por não haver acoplamento, uma
dependência direta de uma função para outra.
. É uma maneira bem flexível para trocar a forma a qual é executada, é possível não executar uma função suprimindo 
e não utilizando o next().

- Instalando Postman.
. Um projeto de API simples, fazendo uma requisição pelo browser ou até mesmo pelo Postman, trazendo o resultado dessa
requisição utilizando JSON.
. Fazendo um projeto de API com Express.js 
. Postman - Uma forma de realizar requisições de uma maneira mais flexível. Testando a API criada. 

- Projeto: API com Express #01.
. Principios importantes do JavaScript no back-end. 
Passo a Passo da criação:

Pasta para realizar a criação da aplicação.
Arquivo package.json. (npm init -y)
Instalação da dependência Express. (npm i --save express)
Criação de uma pasta dentro do projeto (src). Que receberá um arquivo para organização e configuração do express, que
será o framework web para criação do web server.
Declarar uma constante como porta para comunicação com a rede, cada porta está associada a um processo ou serviço 
específico, as portas permitem que os computadores diferenciem facilmente entre diferentes tipos de tráfego. Então 
cada processo que precisa de conexão com rede, terá uma porta, e cada porta será única por aplicação.
OBS: A porta 80 refere-se a requisição ao protocolo HTTP sendo uma porta padrão.
Exportação do express, instanciando o express como função para variável app, e na variável app será feito os serviços
para requisições.
Alterar a main no arquivo package.json para src/servidor.js. 
Dentro do script terá a instalado a dependência Nodemon apenas para área de desenvolvimento. (npm i --save-dev nodemon - 
Caso não esteja instalado).
npm start - Para execução.
Testando a aplicação utilizando Postman (Get)
http://localhost:3003/produtos - Execução da aplicação.
.get() - Associação de uma propriedade ou objeto a uma função que será executada quando tal propriedade é acessada.
Para algumas requisições será declarado a função middleware, que declarará os produtos na aplicação. 
.listen() - É utilizada para vincular e ouvir as conexões no host e na porta especifica. 
Ao final sera declarado uma requisição de execução que terá um callback para informar que o servidor conseguiu executar
a comunicação com a porta declarada.
.send() - Forma de envio do servidor para o usuário. 
.post() - Envia dados ao servidor, geralmente é enviada por meio de um formulário HTML e resulta uma alteração no servidor.

- Projeto: API com Express #02.
. Criação de um Banco de Dados.
Passo a Passo da criação:

Criação do arquivo bancoDeDados em js, na pasta src.
Criação de um objeto que será a sequência dos id que irá representar o produto. 
Utilizar o método get para retornar um id.
Constante produtos para retornar um objeto possuindo chave sendo o id do produto, e o valor sendo o produto informado.
Função para retornar o produto com o id, caso não possua, retornar um objeto vazio.
Função que irá retornar todos os produtos e o id correspondente.
Utilizar o module.exports para exportar o banco de dados para ficar visivel para o escopo global, e realizar o import no arquivo do servidor. 
No arquivo servidor, é criado uma função com o método get recebendo os parâmetros de produto e id para retornará o produto com o respectivo id.
Utilizando o Postman: (GET) & (POST).
Dentro de body
x-www-form-urlencoded - Padrão para envio do formulário.

- Erro do bodyParser deprecated.
. Quando se usa as mesmas dependências do projeto que está sendo desenvolvido, consta uma mensagem a qual exibe o erro.
. Mas mesmo com isso o projeto funciona corretamente, para corrigir esse comportamento:

// Express v4.16.0 e superior
const express = require('express');
app.use(express.json());
app.use(express.urlencoded({
extended: true
}));

// For Express 4.16.0 ou abaixo
const bodyParser = require('body-parser');
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({
extended: true
}));

. No site do Express JS, sobre o bodyParser no Express 4:
As funções de middleware integradas do Express(...), express.bodyParser e (...) não estão mais disponíveis no
objeto express. É preciso instalar manualmente as alternativas e carregá-las no aplicativo.
. Importação do bodyParser:
const bodyParser = require('body-parser');

. E na hora de usar, seria algo como:
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

.Com isso, os erros. Para a continuação do desenvolvimento e essa extensão é usada novamente em projetos de seções
futuras.

- Projeto: API com Express #03.
. Ajustando o erro bodyParser:

No arquivo servidor.js insira, ou seja será feito o parser no body da requisição.
Instalando o bodyParser : npm --save body-parser 
const bodyParser = require('body-parse') - Importação do bodyParser para aplicação.
app.use(bodyParser.urlencoded({extended : true})) - Retorna uma função middleware, chamando a url code que retornarará a função middleware.
.use() - Uilizado para executar a função Middleware dentro de uma aplicação express.
.urlencoded() - Fazendo com que qualquer requisição do servidor, passe pela função middleware e realize o body na requisição. (Padrão utilizado
para envio de dados para aplicação).
Utilizando o Postman:
POST - Acrescentará chaves e valores a aplicação.
GET - Mostrará a lista de produtos acrescentados com o método POST.
Retornando ao servidor: 
Criação de uma função no banco de dados e no servidor para substuição da (chave/valor), utilizando o método:
.put() - Substituição de produtos (chave e valores) a partir do id correspondente.
Criação de uma função no banco de dados e no servidor para deletar produto a partir do método:
.delete() - Para deletar chave e valor associado a aplicação, com o id correspondente.

- Configurando a função scheduleJob.
. Na próxima aula temos um código para executar tarefas agendadas utilizando a função scheduleJob do módulo schedule do Node. Essa função 
recebe como parâmetro uma string de configuração no formato 'segundo minuto hora diaDoMês mês diaDaSemana', que indica quando uma função 
será executada.
Na aula, essa string seta a execução do código para um exemplo específico envolvendo o dia e a hora em que a aula foi gravada, que é 
'/5 * 12 * * 2', o que significa que a função será executada de 5 em 5 segundos, porém apenas durante a hora 12 de uma terça-feira, e se 
você não estiver testando este exemplo em algum momento em que a hora é 12 em uma terça feira, o código não funcionará.
Para resolver esse problema, basta mudar a string de configuração. Você pode optar por personalizá-la de acordo com o dia e hora que você está
realizando o exercício, ou utilizar a string '/5 * * * * *', que simplesmente executará o código de 5 em 5 segundos independente de minuto, 
hora, dia do mês, mês e dia da semana em que você está testando o algoritmo.

- Tarefas Agendadas com Temporizador.
. Criando um temporizador que será um agendamento de tarefas, utilizando o Node.
npm i node-schedule - É uma biblioteca do Node que da possibilidades do agendamento de tarefas.
. Utilizando a função scheduleJob do módulo schedule do Node. Essa função recebe como parâmetro uma string de 
configuração no formato 'segundo minuto hora diaDoMês mês diaDaSemana', que indica quando uma função será executada.
schedule.scheduleJob('*/5 * * * * *') - Executará o código de 5 em 5 segundos independente de minuto, hora, dia do 
mês, mês e dia da semana em que você está testando o algoritmo.
getSeconds() - Método que retorna os segundos de uma data específica de acordo com o horário local.
setTimeout() - Método que define um cronômetro que executa uma função ou trecho de código especificado assim que o
cronômetro expirar.

- Process: Entrada e Saída Padrão.
. Objeto process que poderá ler dados do teclado do usuário e imprimir na entrada padrão (teclado) e saída padrão
(monitor).
. É possivel ler os parâmetro que foram passados em uma execução de uma aplicação de Node, no terminal.
process.argv - Lista de argumentos, declarada ao inicio do código. 
process.stdout - Saída padrão de dados. 
process.stdin.on - Evento que acontecerá a partir do momento que o usuário está passando dados e inserido com o enter.
process.exit - Evento de saída, interrompendo caso não seja inserido nenhum dado.

Seção 11: ESNext.

- Revisão #01.
. Revisão sobre as variáveis VAR LET e CONST e atualizações do ECMAScript 2015/2016/2017. 
. Var e Let - Diferenciando o var de let, o var pode ser acessado dentro ou fora do escopo de bloco, diferente do let, 
que só é visível ao acessar dentro do escopo de bloco, caso seja acessado fora do escopo constará um erro. 
. Template String - Dentro do template é possível colocar variáveis a partir de $ delimitado por {}, delimitando a
string por ``. Quando a string for interpretada, irá ser interpretado o valor da variável, e será substituido na 
string final, lembrando que o template string também considera tab, quebra de linhas, e tudo que estiver dentro dos
delimitadores irá ser considerado string.
. Destructuring - É a forma de tirar de alguma estrutura algo, seja tirar de dentro de um objeto, ou um array ou até
mesmo uma string, então á a desestruturação de valores de alguma estrutura.

- Revisão #02.
. Revisão sobre as funções e atualizações do ECMAScript.
. Arrow Function - É uma forma de declarar uma função, trazendo a sintaxe mais reduzida, priorizando ter funções de 
uma única linha, sendo uma função anônima sendo criada e atribuida a partir de uma constante. Quando se tem um único 
parâmetro não é necessário coloca-lo entre parênteses (), caso tenha um corpo na função é necessário declarar o 
return para retornar.
. Arrow Function (this) - This em uma função arrow é um this que está associado ao local onde a função está escrita.
. Parâmetros Default - Funcionalidade de ter um atributo ou função, e definir um valor padrão, podendo ser alterado 
caso seja declarado o novo valor na execução da função.
. Operador Rest - Irá agrupar os parâmetro em um array internamente dentro de uma função.

- Revisão #03.
. Revisão sobre as objetos e atualizações do ECMAScript.
. ES8: Object.values/Object.entries - Sendo que o object.values mostrará os valores de dentro de um objeto e o
object.entries que mostrará chaves/valores dentro de um array.
. Melhorias na Notação Literal - Se for criado um objeto a partir de uma constante que já existe no código, é possível
criar o objeto, passando somente o nome da variável e será criado o atributo com o nome e o valor da variável. Também
para criação dentro de uma função, não e necessário inserir o function, apenas o nome da função e os parâmetro caso
tenha.
. Class - Também sendo possível a criação de classes, que será internamente convertida para uma função, podendo ter 
herança, criar as próprias funções, e para criar objetos a partir de uma classe é preciso ao declarar colocar new.

- Operador Rest/Spread.
. Permitem trabalhar com múltiplos parâmetros em funções.
. Rest utilizado para colocar o "resto" dos dados contidos no vetor.
. Spread utilizado para "copiar" o conteúdo de um vetor ou objeto para outra estrutura de dados como um array, um 
map ou um conjunto.
. Representado por três pontos: ...

- Tagged Template #01.
. Processar uma template string a partir de uma função.
. São strings que permitem expressões embutidas, podendo utilizar string multi-linhas e interpolação de string com
as mesmas. 
. Trazendo uma nova forma de criar strings e tornar o código mais legível.

- Tagged Template #02.
. Objetivo de controlar o parser de uma template string, a partir de uma função, recebendo os valores da template 
todos separados em um array, e também recebe um array com todos os valores que forem interpolados e com os dois array
sendo possível realizar uma mescla desses dois valores e gerar uma string com um parser diferente.

- Map
. Estrutura que tem a mesma função do objeto tendo pares de chave-valor, lembrando sempre a ordem original da 
inserção da chave.
. Sendo que a chave com o map, pode ser uma função, número, array, objeto tendo mais flexibilidade.
.has - Função que verifica se o elemento está ou não contido no map.
.size - Informa quantos elementos o map possui.
. Não é permitido ter chaves duplicadas, mas podendo ter os valores duplicados. 

- Set.
. Estrutura de conjuntos, que permite armazenar valores sem repetições e valores indexados.
. Desde de valores primitivos a referências a objetos.
. Caso acrescente a um objeto iterável, todos os elementos serão adicionados ao novo SET.

- For Of
. Tipo de laço for.
. O laço do tipo for of intera em cima de valores, podendo utilizar em array, reduce, map, objetos, string, set...
. Podendo percorrer pelo valor, ou pela chave ou pelas entries.
.entries(): Retorna um array dos próprios pares de chave/valor, na mesma ordem dos objetos providos atráves do loop.
.keys(): Retorna um array de propriedades enumeraveis de um determinado objeto.

- Promises. 
. Recurso utilizado para processamento n. 
. Tem dois grandes destinos, que é ser resolvida, e assim a promise é comprida ou não ser resolvida então foi 
rejeita.
. Uma promise está em um dos estados:
pending (pendente): Estado inicial, que não foi realizada nem rejeitada.
fulfilled (realizada): Sucesso na operação.
rejected (rejeitado): Falha na operação. 
. Uma promise pendente pode se tornar realizada com um valor ou rejeitada por um motivo (erro). Quando um desses 
estados ocorre, o método then do promise é executado.
.then() - Retorna uma promise, possuindo dois argumentos, ambos sendo callback sendo uma para promise comprida e 
outro para promise rejeitada.
. Para utilizar a promise, pode ser chamada por new Promise e esse objeto que receberá uma função anônima com 
callback que será Resolve e Reject.
.catch - Retorna a promise rejeitada podendo possuir uma mensagem ao usuário.

- Usando Callbacks Aninhadas.
. Utilizando o link do curso que terá três turmas com dez alunos. 
. Será criado um código para ter o retorno de três arquivos Json com a lista das três turmas. Extraindo apenas os
nomes dos alunos. 
. Apenas utilizando callback sem promise.
. É feito uma função com duas respostas e uma váriavel, sendo a variável para resultado dos dados ao entrar, a 
primeira resposta sendo a entrada de dados no código e a segunda entrada sendo a conversão do resultado para um 
arquivo Json.
. Após isso é realizado um array com todos os dados. 
. E depois será executado a callback hell, sendo uma forma não viável, retornando todos os alunos nas suas 
respectivas turmas. 

- Refatorando Callback para Promise.
. Trabalhando com o mesmo arquivo de código da aula passada. Refatorando com o promise.
. No arquivo passado foi realizado uma callback hell que é uma callback conjunta com outras ocorrendo a execução de
cima para baixo visualmente, evitando erros. 
. Utilizar o promise faz com que o código fique mais organizado e limpo, de forma visível. Evitando ocorrer acumulos 
de informações dentro de uma única callback.
. Ao utilizar o promise
. Sempre que for utilizado o .then, é importante colocar o .catch para que caso ocorra um erro, sempre declarando
após o .then.

- Async/Await.
. Recurso que surgiu na atualização ES08.
. Trazendo a transformação de um código n para um código sicrono.
. Utilizando o mesmo arquivo das duas últimas aulas, sendo que o objetivo é simplificar o uso de promises.
. A parte mais importante é que o Await só será realizado caso seja marcado Async na função.
. Quando uma função estiver retornando uma promise, é possível utilizar o Await, e essa função irá para o próximo 
passo somente se estiver resolvida, ou estiver recebendo o erro.
. Outro ponto importante é que quando é feito uma função Async, sempre é retornado um objeto AsyncFunction, e dentro
do AsyncFunction é chamado o then.

- Novas Aulas Promises & Async/Await.
. Início da revisão e aprofundamento do tema de promise e async/await.
. Aulas extraídas do curso de JavaScript Funcional.

- Promise #01.
. Quando é criado um promise, é o resultado de algo na execução futura do código, podendo ser um valor númerico, uma
string, um valor booleano, uma resposta de uma aquisição, ou até mesmo um conteúdo de um arquivo.
. Então nesse caso para que seja possível gerar esse dado, é necessário passar uma função como parâmetro para promise
. Ao verificar no console com o typeof, uma promise é uma função. E quando é criada uma nova promise, será um objeto.
.then() - Também vai receber uma função como parâmetro, retornando a promise e trazendo o resultado dela também usando 
o conceito de callback para quando o promise for comprido e para quando o promise for rejeitado.
. Uma promise só irá gerar um único valor. Então independente de quando parâmetros forem passados, somente o primeiro
valor será considerado, o restante será undefined.
. Caso seja necessário retornar mais de um valor, é preciso criar um objeto ou uma lista de valores dentro da promise.
. Uma das vantagens de ter uma promise é o fato de que pode ser executado o .then diversas vezes compondo várias 
funções e executando uma após a outra. 
. Podendo criar uma sequência de operações baseadas em forma de funções.

- Promise #02.
. Exercício de promise, porém utilizando callback hell.
. Criando uma função dentro do setTimeout, e criando outras funções dentro da mesma function setTimeout, colocando
uma callback dentro da outra. 
. Assim que é executado, é visivel que o código fica de forma mais alinhado dentro do outro, e devido ocorre uma 
demora ao executar o código.
. Então o código seria n e considerado como uma callback hell que seria utilizado antes da promise existir no 
javascript.

- Promise #03.
. Utilizando o método Promise, sendo não n. 
. Criando uma função para receber dois números, e na promise criada gerar um número entre os dois números de entrada. 
. Podendo ter diversas funções com opções diferente com .then, como aplicar a multiplicação assim que o número
gerado for passado pela promise.
. Receber uma string para informar uma mensagem ao executar no console.

- Desafio Promise e Resolução
. Utilizar a promise para encapsular uma execução de arquivo. 
. Criar uma função de leitura do arquivo tendo como parâmetro o caminho, retornando uma nova promise.
. Recebendo uma função com o parâmetro de resolve, que terá o retorno do caminho e de outra função para após a 
leitura do arquivo. 
. Executando de forma síncrona, chamando o resolve para um conteúdo transformado em uma string.
. Executar a primeira função utilizando o método .then.

- Promise #04. 
. Utilizando o código da aula passada
. Para executar várias promises ao mesmo tempo e somente executar com o .then após todas as promises serem resolvidas.
. Uma função retornando uma Promise.all, informando todas as promessas a serem executada, caso alguma seja rejeitada,
todas também serão.
console.time() - Contador utilizado para monitoração de quanto tempo uma operação é executada. 
console.timeEnd() - Interrompe um temporizador que anteriormente foi iniciado com console.time().

- Promise #05.
. Aula referente de como é o tratamento de erros dentro do contexto de promise.
. No javascript possui uma bloco chamado try{} e catch{}
try{} - É um bloco para se utilizar para teste caso ocorrá um erro será passado para o bloco catch.
catch{} - É o bloco para o tratamento de erro, possuindo uma função chamada catch que será feito o tratamento das
promises. Caso tenha um único erro, será executado com a mensagem declarada no catch.
. Caso seja tratado um erro dentro do método .then, o catch não será executado.

- Async/Await #01.
. No node não é possível utilizar await sem ter uma função assíncrona.
. Async/Await é uma função de forma assíncrona que retornar um objeto, também é possível definir funções assíncronas 
utilizando a expressão AsyncFunction.
. A função async/await tem a finalidade de ter um código que parece síncrono embora seja um código assíncrono.
. Ou seja, ao invés de executar a função .then, ficará parado esperando a execução e só irá dar continuidade caso 
seja executado a linha do código. 
. Retornando uma promise, quando a função retorna um valor, a promise será resolvida com o valor retornado, quando a 
função assíncrona lança uma exceção ou algum valor, a promise será rejeitada com o valor lançado. 
. Contém uma expressão await, que pausa a execução da função assíncrona e espera pela resolução da promise passada, e
depois retoma a execução da função assíncrona e retorna o valor resolvido. 
. A proposta das funções async/await é para simplificar o uso de forma síncrona das promises, e executar alguns 
procedimentos em um grupo de promises.

- Async/Await #02.
. Tratamento de erro.
.includes() - Verifica se um elemento está em um determinado array.
. Utilizando o metódo da aula de Promise #05. Try e Catch.
. Utilizado para tratamento de erros em exceções, o Try consegue recuperar os erros que possam ocorrer no código,
o catch faz o tratamento dos erros assim que acontecem.

- Cenas dos Próximos Capítulos..
. Finalização do capítulo do ESNext.

Seção 12: Conceitos sobre Web.

- Introdução à Web.
. Conceitos importantes antes do capítulo de HTML, tendo uma parte de Infraestrutura.
. Momentos importantes da história da Internet.

1950: Computador Eletrônico - O computador que já era uma realidade, passou a ser um computador eletrônico, tendo a 
base para toda a comunicação em rede entre computadores pessoais.

1960: ARPANET - Departamento de Defesa Americano - No oeste dos Estados Unidos, onde algumas universidades estabeleceram
comunicação entre elas, a partir de uma primeira rede.

1970: TCP/IP - Robert E. Kahn & Vint Cerf - Os dois pesquisadores, definiram o protocolo de comunicação TCP/IP, que
de fato é o padrão usado na Internet.

1980: WWW - Tim Berners-Lee - Um dos pesquisadores, mais conhecidos da história da web, por inventar a web que todos 
conhecem o WWW (World Wide Web).

1990: Internet no Brasil - Quando a internet chegou ao Brasil.

2000: iG, Rede Sociais, Internet em Casa - Quando as pessoas já podiam ter computadores com internet na sua casa, fazendo
conexões através do modem junto com o cabo da linha telefônica. 

. A internet é uma grande rede de computadores, existindo topologias de Redes.
. Centralizada: Que é uma das topologias mais famosas, tendo vários computadores ligados a um nó central. 
. Distribuida: Existe uma forma que está sendo distribuida a partir de vários pontos, tendo rotas de um computador
para o outro, mesmo que uma parte da rede fique fora do ar. 

Web (Teia).
. Tendo vários níveis de redes, por exemplo grandes BlackBones que ultrapassam de um continente para o outro.
BlackBones: É um intermediário na transmissão de mensagens e dados entre redes locais.
. Podendo ter redes de nível 1, 2 ou 3.

Transmission Control Protocol / Internet Protocol - TCP/IP.
. Base da internet sendo um protocolo da camada de transporte, é um protocolo orientado a conexão e é um protocolo
confiável.
. Tendo em contrapartida o UDP e User Datagram Protocol, que é um protocolo não orientado a conexão, sendo
baseado no melhor desempenho não garantindo a confiabilidade que o TCP tem, recomendado por ser um protocolo mais 
leve.
. O TCP possui um handshake, que é uma conversa preliminar entre as duas pontas, para que de fato o dado seja 
transferido. 
. O IP é o protocolo responsável por realizar a comunicação entre redes, o roteamento entre redes. 
. O TCP/IP é um protocolo baseado em um padrão de projeto chamado linhas, um protocolo que é uma aplicação de software,
e esse software usa um padrão de projeto chamado layers.
. Separado em camadas, e cada camada possui sua própria responsabilidade.
O TCP/IP possui as camadas:
    Aplicação
    Transporte         
    Internet       
    Rede/Física
. A dependência da camada de cima utiliza o serviço da camada de baixo e assim sucessivamente para fazer a 
comunicação entre as camadas.
As responsabilidade de cada camada:

Rede/Física: Um tipo de conexão que é física, por exemplo: 
.Ethernet - Wi-Fi
.MAC address: Endereço relacionado a interface de rede. 
.Física (Hardware) e Enlace (Software).

Internet: Camada que possui:
.IP - Internet Protocol: endereço que identifica uma máquina dentro de uma rede.
.Conexão entre redes.
.Transferência de Pacotes.
. Então há uma conexão entre redes e o protocolo IP, que faz a transfêrencia de pacotes. Existe o conceito de pacotes
a partir da camada de Internet e é nessa camada que é realizada a comunicação entre redes.

Transporte: Comunicação entre máquina a máquina, pondendo sair de uma máquina específica para uma determinada máquina
específica para que haja comunicação entre as duas.
. TCP (Confiável), UDP (Melhor Desempenho).
.Comunicação Host-A-Host.
.Confiabilidade, integridade.

Aplicação: Tendo uma comunicação processo a processo. 
.HTTP, FTP, SMTP...
.Comunicação Processo-A-Processo.
.Número da Porta.

Anatomia do endereço IP:
IP v4 
        Classe A: 192.168.100.230       Sub Rede: 255.0.0.0
. Um número separado por quatro partes e cada parte é de 0 até 255. Parte desse IP está destinado para identificar a
rede que o computador está e parte desse IP está para identificar o computador dentro de uma rede.
. O empenho de Classe A é classificado sendo a primeira parte destinada a rede, e as três últimas partes estão 
destinadas para definir a máquina ou host. Nesse caso da Classe A é visivel de ver que possui poucas redes e dentro
de cada uma das redes possui muitas máquinas. 
. Nessa organização, para definir o que é rede e o que é host, um conceito de máscara de sub rede, sendo um número 
que está associado com o IP.
. Tendo o mesmo tamanho de um IP, quando a máscara de sub rede tem um determinado bit marcado com um significa que
aquela parte do IP aponta para uma rede.
. E sempre que na máscara de sub rede um bit estiver com o zero, significa que o bit correspondente aponta para uma 
máquina.
. Dividido normalmente para o lado esquerdo sempre terá bits 1 e para o lado direito sempre terá bits 0.
        Classe B: 192.168.100.230        Sub Rede: 255.255.0.0       
. O endereço pode ser o mesmo que o da Classe A, porém o que irá definir a classe será a máscara de sub rede.
. Sendo que na sub rede, as duas primeiras classes irá definir a rede, e as outras duas o host.
. Utilizamos mais o endereço de Classe C.
        Classe C: 192.168.100.230         Sub Rede: 255.255.255.0
. Tendo alteração também somente na máscara de sub rede, fazendo com que as três primeiras partes mapeiam a rede e 
apenas a última parte mapeia o host, isso fará com que limite o número de máquinas utilizando o mesmo endereço IP,
que seria por volta de 255 máquinas. 
. Podendo ter máscaras ainda mais restritas, mas os três padrões acima são os mais clássicos utilizados. 

Conceito de Porta...
. Para fazer comunicação entre duas máquinas com o endereço de IP diferente, é preciso saber qual é o processo, sendo
o mapeamento feito pela porta.
. Então será feito uma comunicação através do processo entre duas máquinas.

OBS: MAC address: Endereço relacionado a interface de rede.

- Protocolo HTTP.
. Hyper Text Transfer - Protocolo de Transferência de Hipertexto.
. Hipertexto é um texto que tem links associados, documentos escritos em HTML, que é Linguagem de Marcação de Hipertexto,
tendo textos em links, podendo fazer referências a outros formatos de arquivos, como imagens, CSS, Js entre outros.

Características do HTTP.
. Faz parte da camada de aplicação, sendo o último nível da camada, onde os desenvolvedores interagem muito com o 
protocolo HTTP.
. Sendo um protocolo Stateless, toda conexão é como se fosse a primeira vez que é aberto, enviando e recebendo
dados. 
. Protocolo Cliente-Servidor, No conceito de requisição e resposta, baseado na url que quando uma url com um conjunto
de parâmetros faz uma requisição e retornado uma resposta. A resposta pode ser um arquivo texto no formato JSON, 
um HTML, um vídeo, ou outros arquivos.
. Opera em cima do TCP IP. 
. E também é um protocolo que irá retornar conteúdos para formar uma página web.

Fluxos básico de uma conexão HTTP.
1 - Usuário informa a URL
2 - Browser gera a requisição. 
    GET/HTTP/1.1
    Host: www.google.com.br
3 - Servidor Web gera a resposta. 
    HTTP/1.1 200 OK
    content-Type: text/html; charset=UTF-8
    date: Mon, 30 Abril 2018 17:00:02 GMT
    connection: close 
    content-Length: 438
    <html>...
4 - Browser exibe a página.

Métodos do HTTP.
. O protocolo http, define um conjunto de métodos de requisição responsáveis por indicar a ação a ser executada para
um recurso. Também conhecidos como HTTP Verbs, sendo: Get, Post, Put, Delete, Trace, Options, Connect e o Head.

Requisição e Resposta.
. Um exemplo de requisição e Resposta.
. Um cliente envia uma requisição para o servidor usando a url mais um conjunto de parâmetros, e o servidor envia 
como resposta para o cliente um HTML, CSS, JS, entre outros...
. Para montar uma página o fluxo de requisição e resposta é feito diversas vezes. 
. Uma das técnicas que é utilizado no desenvolvimento web, é reduzir o número de arquivos comprimindo o máximo 
possível em um único arquivo, ou em poucos arquivos para não sobrecarregar a carga inicial do site. 

Requisição via GET.
. A requisição possui a url, tendo parâmetros da requisição. 
. Exemplo no browser:
Inserindo a URL que será feita a requisição www.google.com.br/search
Após isso é feito uma separação dos parâmetros da url
? - Divisor entre a URL e os Parâmetros.
q=web+moderno - Parâmetro q que recebe uma query e o valor do parâmetro q que é web+moderno. Query é a consulta que é 
realizada em cima do search.
&hl=pt-BR - Parâmetro para informar qual língua da máquina host para que possa enviar o resultado na língua descrita.
. Então quando é utilizado uma requisição do tipo GET, os parâmetros irão na própria url.
. Quando é em uma requisição tipo POST, os parâmetros irão no corpo da requisição.

Requisição via POST.
. Utilizando o verbo, o método do http Post.
. Nesse caso o Post irá fazer requisição no host com o endereço: accounts.google.com/signin.
. Dentro do corpo da requisição irá ter os parâmetros que vão ser enviados para que a requisição seja processada.

Grupos de Status de mensagens do HTTP.
1xx - Mensagens de Informação.
2xx - Mensagens de Sucesso.
3xx - Mensagens de Redirecionamento.
4xx - Mensagens de no Cliente.
5xx - Mensagens de Erro no Servidor.

- Slide do Capítulo.

- Servidor Web.
. Existem diversos tipos de servidores, como o Apache, Tomcat, Jboss, Nginx, Microsoft IIS, até mesmo o NodeJS que não é 
propriamente um servidor web mas possui mecanismos para transformar em um servidor web, tanto para provê conteúdo 
estático como conteúdo dinâmico.
. Podendo ter um servidor web dentro de uma linguagem, podendo codificar para executar uma porta e atender diretamente 
na linguagem que foi codificada.
. Frameworks, como o SpringBut, que internamente embutido na própria aplicação possui um servidor web.
. Tendo diversas ferramentas e possibilidades para estratégias diferentes.
. Tomcat e Jboss são aptos para receber aplicações em Java.
. NodeJs seria para receber aplicações em JavaScript.
. Nginx e Apache pode executar conteúdos estáticos que podem servir como um proxy reverso, que pode ter várias 
técnologias atrás de um servidor frontal, e utilizar o PHP dentro dos servidores, com os módulos do PHP para interagir
com os servidores e realizar uma aplicação em PHP.

Web | DNS
                Cliente.

Web Server                          DNS Server
23.67.100.3                         8.8.8.8

. Quando uma determinada máquina Cliente, acesse o site criado, o site contendo o endereço IP como uma máquina servidor
baseada no protocolo HTTP, tendo uma requisição a partir de um cliente - servidor.
. Quando a máquina cliente inserir a url, antes de conseguir chegar diretamente no servidor que de fato irá executar a 
página renderizando no browser é necessário que uma consulta no DNS seja realizada. 
. Então em um determinado servidor DNS, que tem o domínio url.com.br, quando é cadastrado e comprado um domínio.
Dentro desse domínio é possível definir todos os registros do DNS.
. Para ter um servidor web que está visível na internet é necessário um resistro desse endereço público aberto.

Virtual Hosting.
. Dentro de um servidor web, é muito comum ter um único servidor web para atender múltiplas requisições. E com a url de cada 
requisição que é possível determinar qual o site que irá ser retornado para atender aquela requisição.
. Mas no geral quando uma aplicação é grande também pode possuir vários servidores web, para atender um único sistema, podendo
ser a partir de uma técnica de balanceamento e carga, que será dívidido a carga em diversos servidores que não possuem 
comunicação entre si, ou podendo ter um conceito de cluster que é um conjunto de máquinas que se conhecem entre si para atender 
em uma aplicação de um porte maior.

Estrutura de Pastas.
. Dentro de um servidor é comum ter uma estrutura de pastas de arquivos estáticos.
. Em comum quando é feito na prática, ao publicar em um sistema de produção, todos os arquivos estáticos como imagens, css, javascript, é 
encaminhado para outro servidor especializado em entregar conteúdo estático. 
. CDN - Content Delivery Networks - São redes de alto desempenho que replicam os dados, por exemplo todos os arquivos do site, css, javascript,
imagens, em diversos lugares do mundo, e quando um usuário faz uma requisição, o sistema que entrega esses dados replicados, vai verificar qual 
é o local que está com a latência menor para aquele usuário e vai fornecer os dados a partir do servidor que está mais próximo.
. Então é indicado que seja separado da instalação a produção.

Web Stack.
. Conceito de um servidor sem seu operacional, que contém: Sistema operacional, web server, DB, linguagem.
. A web stack mais famosa que possuem as propriedades acima é o LAMP:
Linux - Apache - SQL - PHP.
. Podendo ser instalado o pacote contendo todos em um único wizard. 

- Client Side vs Server Side.
. Diferenças em uma aplicação em server side e client side. 

Evolução das Arquiteturas:
. A primeira arquitetura de uma aplicação distribuída dentro do ambiente de rede era uma aplicação em MainFrame, que foi na primeira
era, onde os terminais eram leigos acessando uma aplicação no MainFrame. Tudo era centralizado, a lógica, geração da tela, e o terminal
servia apenas para digitar informações de entrada e assim seria direcionado ao MainFrame. 
. A segunda era cliente-servidor, nessa época possuia aplicações de duas camadas, ou três camadas que era o cliente que era uma aplicação 
desktop com regras de negócios implementadas no próprio cliente, um servidor desenvolvido, e era possível o cliente acessar o banco de dados.
Então na época a arquitetura cliente servidor no qual a aplicação desktop era uma aplicação única em que diversas coisas eram processadas do
lado do cliente e o servidor servia muitas vezes apenas para ter os dados centralizados a partir de um banco de dados.
. E então a era da web-server-side, que possuia uma aplicação server site que é uma aplicação da lógica, toda a renderização das
páginas são processados do lado do servidor, então a máquina do usuário, o browser do usuário serve apenas de certa forma um terminal leigo,
podendo ter uma interação com o front-end, algo do tipo para validar, ou uma animação na tela de uma forma talvez menor, mas a regra é 
que as aplicações web, server site será o conteúdo gerado do lado do servidor. Nesse caso a arquitetura tem uma distribuição muito simples
por conta de ser web, então uma vez que é atualizado o site automaticamente todos os clientes estarão atualizados.
. A era do Front-end + services, que é exatamente as aplicações front-end ou aplicações client-side, voltando para era que a aplicação era 
desktop, tendo uma aplicação rica que tem diversos comportamentos dentro dessa aplicação e o acesso ao servidor é um acesso para 
obter dados. Então um servidor ou um código implementado servidor para aplicar regras de negócios, gerar web-server, e obviamente ao 
gerar o web-server não é recomendado expor o acesso aos dados diretos então é necessário aplicar filtros de validação, camadas de segurança.
Tendo clientes ricos ou seja parte da renderização dos componentes, regras de detalhes visuais, ou até mesmo mensagens de erros que é 
gerado do lado do cliente utilizando o javascript. 
. Então a aplicação server-side o conteúdo html é gerado a partir do servidor, não apenas dados são enviados do servidor para o browser,
mas o html é gerado do lado do servidor e é enviado essa informação para renderizar no browser.
. Quando é trabalhado com uma aplicação front-end, uma aplicação client-side é comum ter o conceito de SPA - Single-Page Application, que 
é uma aplicação que tem uma única página, que na primeira página é renderizada e a partir dessa página é executado o javascript que foi
utilizado para realizar a aplicação e toda parte visual, é construído e gerado dinamicamente pelo javascript e pelo código javascript.
E não mais gerado pelo servidor, o servidor passa a ter serviços web uma arquitetura comum tendo web-server, que geram dados e podem ser
no formato XML, mas de forma mais comum é o formato JSON.

- Conteúdo Estático vs Dinâmico.
. Diferença entre conteúdo estático que é algo que está parado na página e conteúdo dinâmico é o que está se movimentando, focado ao lado do 
server-side. 
. O conteúdo estático, o servidor quando renderizar uma a página realiza leitura de arquivos no disco, arquivos estáticos que estão gravados
e executa a página, apenas com conteúdo de arquivos que foram gerados a partir da leitura de arquivos físicos do servidor web.
. O conteúdo dinâmico, é o conteúdo que é gerado a partir de um código. Pondendo incluir na página a hora certe, informações que são omitidas 
do banco de dados para gerar um arquivo personalizado, baseado em um filtro que o usuário fez. 

- HTML, CSS e JS.
. Três tecnologias que estão extremamente relacionadas. 
HTML: Linguagem de marcação, sendo a parte estrutural da aplicação.
CSS: É a parte que irá definir o estilo e design da página. 
JS: Seria a parte do comportamento dinâmico obtida a partir do Javascript.
. Utilizando as três tecnologias integradas é possível desenvolver uma aplicação web completa, na parte de front-end. 
. Nos dias de hoje, utilizando o framework React é possível ver o html e o js gerando um conteúdo dinâmico, então o foco do React não é 
tanto separar as tecnologias, mas sim separar as funcionalidades em componentes. É possível sim separar as tecnologias desde que o componente 
faça sentindo em serem isolados para que o conjunto de componentes uma aplicação maior. 

- DNS.
. Servidor DNS.
. Tem a ideia de traduzir os nomes de domínios em endereços IP. Sendo um registro em uma tabela para realizar esse mapeamento, de nomes de 
domínios para endereços IP, podendo ter um domínio apontando para outro caminho, um DNS que dentro tem a referência para outro DNS, registros
textuais para validação, entre outros.
. Quando é criado um domínio, é necessário fazer no site do Regristro BR. E no site tanto é possível comprar o domínio como utilizar um gratuito.
ao criar é preciso colocar as referências do domínio como a url, o nome do IP.
. O DNS funciona sobre o protocolo UDP na porta 53.
Funcionamento básico do DNS.
1 - Usuário informa o endereço no browser.
2 - Computador envia uma consulta DNS, para o servidor local.
3 - O servidor responde com o endereço IP. (Então será convertido o nome passado pela consulta, devolvendo o IP)
4 - Computador acessa o servidor a partir do IP obtido.
. Existem dois tipos de busca que o DNS poderá fazer sendo:
Busca Recursiva.
. Tendo um cliente DNS, que irá acessar determinado endereço, e associado ao cliente tem um servidor DNS, ao acessar a algum endereço, e feito
Uma pesquisa de DNS recursivo é onde um servidor de DNS se comunica com vários outros servidores DNS para buscar um endereço de IP e
devolvê-lo ao cliente. Na recursiva, um DNS chama a si mesmo repetidamente até que uma condição seja atendida.
Busca Iterativa. 
. Uma consulta de DNS iterativa, é quando o cliente se comunica diretamente com cada servidor de DNS envolvido na pesquisa. Na iteração, um 
conjunto de instruções é repetido até que uma condição seja atendida.

DNS Records

A - IPv4
. Registro para criar um subdomínio que será vinculado a um domínio ao endereço IP.
AAAA - IPv6 
. Registro para criar um subdomínio que será vinculado a um domínio ao endereço IP.
MX - Servidor de e-mail
. Registro do DNS para criação de um servidor responsável de e-mail.
NS - Servidor DNS
. Registro de criação de um DNS apontando para outro DNS.
CNAME - Canonical Name (Apelido)
. Registro DNS que mapeia um nome de domínio normalmente são usados para mapear um subdomínio.

- HTTP Seguro (HTTPS).

. Protocolo HTTPS, executa em dois tipos de protocolos, que a comunicação é criptografada ou seja é um http seguro.
HTTP + TLS (Transport Layer Security Protocol) 
HTTP + SSL (Secure Sockets Layer Protocol)
. São dois protocolos que juntamente com o HTTP faz com que as navegações sejam seguras. Não sendo compatíveis pois as versões são uma
atualização da outra.
. Os dados são criptografados usando os protocolos TLS ou SSL, garantindo que a informação saindo da máquina e sendo exposta ao servidor,
e diversas redes diferentes, que não seja possível criptografa a mensagem que está meio. 
. São protegidos contra interceptação (MITM), o que está no meio monitorando a rede não é permitido fazer a leitura do que está passando
dentro de uma conexão https.
. Criptografa todas as informações, então a url juntamente com toda requisição e também tudo que é devolvido como resposta,
então tudo seria criptografado deixando apenas o IP para ser visível.
. Utiliza certificados digitais.

Autoridades Certificadoras.

SA - Organizações que emitem e validam os certificados, disponibilizando para quem comprar ter um pacote instalavel para habilitar 
o HTTPS, que é a comunicação entre o servidor web e o browser, no browser também é necessário ser instalado para que na hora de 
criptografar o servidor para o browser, seja possível descriptografar os dados. 
Let's Encrypt - Autoridade certificadora que é gratuita para gerar um certificado válido. Utilizando o certbot realizando todas as
configurações no terminal, automatizando a instalação do certificado digital.

- Web Service. 
. É um serviço web, sendo um serviço que a aplicação que provê uma facilidade de interoperabilidade entre diversas linguagens diferentes.
. Um serviço que executa em tecnologias web que a comunicação dos dados seja de forma textual, existindo duas alternativas de utilizar o web
service, sendo:

Simple Object Access (SOAP)								

. Versão Antiga, sendo mais burocrática.
. Conceito utilizado: WSDL - Web Service Description Language, sendo um XML que descreve quais são as funcionalidades que o determinado 
serviço utiliza e os métodos que o serviço disponibiliza, como são os dados, entre outras descrições. 
. Um protocolo tendo o formato XML, tanto para requisição e resposta. 
. Conhecido também como RPC - Remote Procedure Call, podendo executar procedimentos ou funções remotas. 

Representational State Transfer (Rest)

. Utiliza o formato JSON e HTTP.
. São requisições e respostas ou seja fazendo uma requisição para uma URL, e dependendo do tipo do verbo do HTTP, terá uma convenção 
chamada RESTful, que se for seguida a convenção estabelecida, significa que o serviço será aderente a essa especificação.
. Sendo mais simples e utilizando os verbos do HTTP.

Convenção do RESTful.
. Tendo um padrão de URL que é convencionado, utilizando um método HTTP associado a uma URL, dando a descrição do serviço dentro do padrão REST
que será realizado.
. CRUD - Create, Read, Update e Delete - São operações básicas utilizadas em banco de dados.  

    URL                 Método                  Descrição
/clientes               POST                    Novo cliente.
/clientes               GET                     Obtém todos (Obtendo todos os 20 primeiros registros).
/clientes/36            GET                     Obtém cliente 36 (Obtendo o cliente a partir do id).  
/clientes/12            PUT                     Atualiza cliente 12.
/clientes/41            DELETE                  Exclui cliente 41.

Escolhas Arquiteturais.
. Exemplo de duas arquiteturas baseadas em serviços.
SOA e Micro Service. 

SOA - Arquitetura antiga, baseada em serviços, tendo diversos serviços que são instalados dentro de um ESB - Enterprise Service Bus, 
um software, que é possível realizar a instalação dos serviços utilizando linguagens para ajustar e implementar fluxos de negócios na aplicação.

Micro Service - Um padrão moderno de arquitetura, utilizado para uma aplicação maior e dividindo em pequenos módulos auto contidos. Possuindo 
serviços especializados para cada módulo, gerando diversas equipes para realizar a manutenção. Uma aplicação tendo uma arquitetura de micro
serviços é possível ter tecnologias diferentes usando banco de dados diferentes.

- Computação em Nuvem.
. Refere-se ao fornecimento sob demanda de recursos de TI através da Internet. 
. Sem utilizar Software ou Hardware, utilizando uma tecnologia hospedada em um banco de dados remoto, podendo ser gratuito ou mediante assinaturas.
. Existem diversas classificações diferentes e as clássicas são:
. Infraestrutura como serviço (Iaas) - É o mais popular entre empresas que buscam autonomia na configuração e gerenciamento de aplicações, sendo 
possível ter alguns recursos de processamento, memória, armazenamento, banco de dados, servidores entre outros, podendo utilizar a nuvem pública
privada ou híbrida, e apresentando um modelo on-demand que permite com que a empresa pague apenas pelo que usar. 
. Plataforma como serviço (PaaS) - Permite que empresas desenvolvam, executem e gerenciem aplicativos em nuvem, sem a necessidade de manter a 
própria infraestrutura e servidores.
. Software como serviço (SaaS) - É uma forma de disponibilizar softwares e soluções de tecnologias por meio da internet, como um serviço. Com esse 
modelo, uma empresa não precisa instalar, manter e atualizar hardwares ou softwares. 

Seção 13: HTML.

- Anatomia da TAG.
. HTML Hypertext Markup Language - É uma Linguagem de Marcação de Hipertexto, ou seja um texto que faz uma referência a outro texto e a partir 
de um link está o texto que foi referenciado.
. TAG é a nome que é dado para a marcação na linguagem, definida por <>, e dentro é informado o nome da tag, podendo ser com letras maiúsculas 
ou minúsculas, podendo ter corpos ou não.
. Sendo possível criar tags próprias com seus componentes e a partir de uma única tag, referêciar um código que está por trás que tem HTML, CSS e 
JavaScript, criando os componentes web.
<tag> - Abertura da Tag
</tag> - Fechamento da Tag
<!-- --> - Para realizar um comentário.
. Podendo ter diversas tags uma dentro da outra. No HTML tem uma série de marcações pré definidas para que se possa construir um documento.
. Para criar tags sem corpo insira: <tag />.
. É possível colocar parâmetros dentro da tag independente se tiver corpo ou não, para colocar os parâmetros insira: 
<tag param1 = 'Valor'>
. O html também possui parâmetros pré definidos que cada uma das tags suporta.
. Com as propriedades também é possível colocar apenas a chave, e o valor será associado a um valor booleano verdadeiro ao atributo declarado.

- Anatomia de uma Página HTML.
. Dentro de um documento HTML é possível integrar trechos de códigos javascript e css.
. A estrutura básica de um html que é envolvido por uma única tag que é <html> </html>, e dentro desse corpo possui duas tag:
<head> </head> - O cabeçalho da página, incluindo títulos, links e outros. 
<body> </body> - Representa o conteúdo do documento html, permitindo apenas um body por documento.
<h1> </h1> - São os cabeçalhos e possui seis níveis que é possível colocar em uma página html.
. Na atualização do HTML 5, surgiram alguns elementos que possui uma ideia semântica e não são elementos visuais. 

Criação do arquivo HTML.
<!DOCTYPE html> - Utilizando o HTML versão 5.
<html> </html> - Para iniciar o código em html.
<head> </head> - Elementos não visuais com exceção do título, tags de metadados, importar arquivos javascript, importar css, entre outros 
arquivos externos.
<title> </title> - Título da página.
<body> </body> - Sendo o corpo da página onde é realizado a organização da mesma, contendo outras tags.
. A página do html é dívidida em duas grandes partes, sendo a primeira parte a do head, onde irá o título e algumas tags e também importações ou 
refêrencias de arquivos css, javascript e links. 
. No body é onde será feito a organização da página, tendo um cabeçalho, conteúdo da página, menu da aplicação entre outros.
<header> </header> - Representa um grupo de suporte que faz a introdutório ou navegacional, podendo conter também outros elementos como um logo, 
cabeçalho, formulários, pesquisas, entre outros. 
<nav> </nav> - É uma seção de uma página que encaminha para outra página ou para outras áreas da página, ou seja uma seção de com links de 
navegação.
<section> </section> - Serve para definir uma seção em um documento, possuindo sempre um título com poucas exceções. 
<footer> </footer> - Representa o rodapé para o conteúdo de seção ou seja o rodapé do section mais próximo. 
<meta> </meta> - Definição de qual caractere será utilizado na página. O mais utilizado é o UTF-8.

- Um pouco de CSS.
. O CSS é uma forma previsível de se escrever, possui pré processadores, fazendo com que seja mais usável sendo possível criar vários mecanismos 
para que possar se escrever de forma mais sustentável.
. Existem três formas básicas para fazer a conexão do CSS com o HTML sendo:
Podendo ser aplicado a partir do próprio nome da tag.
Podendo ser aplicado o estilo em cima de um determinado tipo de Class.
Podendo ser referenciado a um arquivo a partir de uma propriedade chamada ID.
. Todas as tags do html, possuem um id que é um identificador único dentro de uma página. 
. Class também é um identificador, utilizado para que possa aplicar uma determinada classe mais de uma vez dentro da 
página, podendo ter diversos elementos marcados com a mesma classe.
. É possível marcar um elemento com mais de uma classe.
. Então para criação do CSS dentro do HTML será mencionado a tag que será aplicada o CSS dentro da tag style e dentro
de { }, será feito a descrição das propriedades.
.MencionandoAClass - Para aplicar CSS em uma Class, será mencionada a partir de um .
#MencionarUmId - Para aplicar CSS em um id, será mencionada a partir de #.
document.querySelector('') - No browser dentro do console, é possível achar um elemento pelo Id e Class.
. O recomendado é ter um arquivo apenas para o CSS, apenas referenciando no arquivo HTML.

- Live Server.
. Instalação do Live Server, um simulador local para páginas dinâmicas e estáticas.
. Possuindo diversas vantagens, sendo um simulador estável o mais vantajoso. 

- Estruturando os Exercícios.
. Utilizando o terminal e instalando HTTP-server. (npm i -g http-server)
. Dependência do Node para provê a execução da página a partir do servidor.
. Criando um arquivo index.html onde estará a estrutura básica do HTML5. 
. Utilizando o terminal, e inserindo: http-server . . Será iniciado um servidor apontando para a pasta criada, com a porta 8080.
. Criando tags no html o header para o cabeçalho, nav referenciando a um link que será teste em html, após a nav terá uma section como conteúdo
e ao decorrer da aula será colocado as páginas que serão carregadas a partir da navegação.
. Criando uma pasta de exercícios e um arquivo teste.html e utilizando o terminal, e inserindo: http-server . . Será iniciado um servidor 
apontando para a pasta criada, com a porta 8080.
http-server -p 9090 - Executará em outra porta dependendo da porta indicada.
. Colocando a tag o footer no html para o rodapé da aplicação. 
. Com o link será introduzido uma requisição Ajax e o conteúdo irá para section de conteúdo. 
. Colocando a tag script para interceptação da aplicação. Como a interceptação do link gerado para que seja criado uma requisição manualmente e
não o browser realizando automaticamente navegando para outra página. 
Para isso será inserido o document.querySelectorAll() que será selecionado todas as tags mencionadas pelo nome dentro de (). Retornando uma lista
de tags. Com o foreach é possível realizar uma função que retornará o link.onclick, associando a uma função quando o usuário clicar. 
e.preventDefault() - Váriavel que recebe o evento do click, prenvenindo que a navegação ocorra.
. Ao clicar no link será feito uma chamada Ajax, pegando o conteúdo da página e colocando dentro da seção relativa ao conteúdo. Então 
irá somente ter uma única página que é a principal e a partir dos links, será pego outros conteúdos parciais e colocando dentro de uma área relativa 
ao conteúdo. 
document.getElementById('conteudo') - Retorna a referência do elemento atráves de seu ID.
fetch() - Função recente baseada em promisse que fará uma requisição Ajax.
.innerHTML - Retorna todo o texto e o html que existe no elemento.

- Texto Puro vs Browser.
. Desafio de um texto em um arquivo html porém sem utilizar as tags. 
. O browser irá interpretar mesmo que não haja um documento escrito em HTML, fazendo o esforço necessário para renderizar.

- Tags para Textos #01.
. Principais Tags do HTML
. Utilizando o código das aulas anteriores - Index.html.
. Css para colocar espaçamentos entre o conteúdo exbido ao clicar.
. Criação de um arquivo html Texto.
<h1> </h1> - Cabeçalho que traz ao texto que está dentro dele tenha a maior relevância dentro da página. Contém seis níveis de cabeçalho, alterando os tamanhos de visibilidade.
<p> </p> - Utilizados para marcar os Paragráfos.
<b> </b> - Tag para colocar um texto em negrito.
<i> </i> - Tag para colocar um texto em itálico. 
<sup> </sup> - Tag para colocar o texto sobrescrito.
<sub> </sub> - Tag para colocar o texto subscrito.
. Não será considerado pelo HTML espaço ou quebra de linhas em palavras. 
&nbsp; - Para determinar espaços em branco.
<span class="3"> </span> - Tag que determina os espaços em branco e a partir da class é informado quanto será o espaço.

- Tags para Textos #02.
. Continuação das Tags do HTML. 
. Criando um novo arquivo de texto e inserindo na seção da página que está sendo utilizada durante o capítulo em html.
<br> </br> - Tag para quebra de linha ao inserir o texto entre a tag, antes e depois.
<hr/> - Tag para inserir uma quebra temática sendo uma linha na página.
<strong> </strong> - Utilizada para marcar como alerta, sendo uma marcação semântica em um determinado texto.
<em> </em> - Marca o texto que tem ênfase, aninhado com cada nível de aninhamento indicando um grau maior de ênfase.
. Para as Tags de marcações semânticas é possível mudar o estilo em geral pelo CSS.
<blockquote> </blockquote> - Utilizado para fazer citações longas, usando referências.  
. Instalação da extensão Preview - Extensão do VS.
<q> </q> - Tag para citações porém citações curtas. 
<abbr> </abbr> - Representa abreviação fornecendo uma descrição completa.
<cite> </cite> - Faz referência a uma obra ou trabalho artístico. Incluida junta com a tag de abreviação.
<dfn> </dfn> - Marcação de uma definição sobre o termo dentro de um paragráfo ou uma seção.
<address> </address> - Utilizada para referênciar um endereço, podendo incluir qualquer tipo de informação de contato, como URL, e-mail, telefone, mídia social. 
<del> </del> - Faz uma remoção da parte do texto inserido entre a tag.
<ins> </ins> - Representa uma parte do texto que está sendo inserida.
<s> </s> - Renderiza um texto com uma linha cortando o texto, utilizado para representar textos que não sejam relevantes ou que não estejam corretos.

- Listas.
<ol> </ol> - Utilizada para criar listas ordenadas, ou seja um Order List.
<li> </li> - Tag para inserir os itens dentro de uma lista, independente se for uma lista ordenada ou não ordenada.
<ul> </ul> - Utilizada para criar listas não ordenada.
. Uma lista ordenada quando os itens são inseridos serão organizado com números em ordem crescente a partir do número um. No caso das não ordenadas 
serão organizadas com bullets.
<dl> </dl> - Utilizada para criar listas que possuem pares de termos e descrições. Uso muito comum para implementar um glossário ou exibir metadados, possuindo uma lista de
pares chave e valor.
<dt> </dt> - Identifica um termo na lista de definição, ocorrendo somente em um elemento por item dentro de <dl>
<dd> </dd> - Fornece os detalhes ou uma definição completa do termo definido por <dt>.

- Listas Aninhadas.
. É possível criar uma lista em um item que está em uma lista.
. Desafio: Ao acessar diretamente no console a lista aninhada como estrutura de arvore. E ao clicar em cima do item principal da lista seja expandido e recolhido os itens de dentro.

- Lista Aninhada (Desafio)
. Resolução do Desafio da aula passada.
. Marcando as pastas com <span> e com o arquivo próprio do curso, para localizar com facilidade pelo javascript.
. Utilizando document.querySelectorAll para selecionar todos os elementos com a propriedade marcada. 
. Função para associar as pastas em um evento onclick que será associado a um evento. 
. Evento que fará com que a lista se não estiver vísivel, ficará e caso contrário recolha a lista. Definindo pela ul do arquivo um style do css.

- Link #01.
. Conhecidos como hiperlinks, seria a inclusão de um texto linkado, podendo vincular documentos, disponibilizar aplicativos em um endereço web simples.
. Então qualquer conteúdo da web pode ser convertido em um link, para quando for clicado fará com que o navegador vá para o outro endereço.
. Um link básico é criado envolvendo o texto que será transformado em um link direto de um elemento a partir da tag <a> que possui um atributo href que 
conterá um endereço da Web onde o link será apontado ao clicar
. Ao declarar a url, inserindo a propriedade ="_blank", faz com que seja aberto outra guia do navegador não saindo da url atual.
. A URL Absoluta aponta para o local definido por sua localização absoluta na web, incluindo protocolo e o nome de domínio.
. Sobre a URL Relativa aponta para um local relativo ao arquivo do qual estará vinculado. 

- Link #02.
. Links para navegar na mesma página e também criando links para envio de e-mails.
. Utilizando a tag <a> e o atributo de mailto: e-mail. Sendo possível ser criado links ou botões que quando clicados, abrem uma nova mensagem de e-mail
de saída em vez de vincular a um recurso ou página. 
. Para navegar na mesma página utilizando o CSS Line, será acrescentado uma div com um id a partir do comando div#nomeDoId. Com as propriedades de CSS fará com que a 
navegação seja em baixo na página, contendo uma tag <a> com um link que referenciando o ID. Fazendo com que o browser navegue até a parte do ID criado.

- Tabela.
. Criação de uma tabela para exibir dados na página, existem diversas formas de utilizar tabelas. 
. Arquivo de tabela em html e introduzir ao index da aula que está sendo utilizada no capítulo.
. Principais tags para criação de Tabelas.
<table> </table> - Tag que define uma tabela.
<caption> </caption> - Representação da tabela. 
. Dentro da tabela possuem três grandes regiões: Cabeçalho, Corpo e Rodapé.
<thead> </thead> - Define um conjunto de linhas definindo a cabeça das colunas da tabela.
<tr> </tr> - Elemento que define uma fileira de células em uma tabela. As células podem ser estabelecidas usando uma mistura de elementos <td> (Célula de Dados) 
e <th> (Célula de Cabeçalho).
<td> </td> - Definição de uma célula de uma tabela que contém dados.
<th> </th> - Cabeçalho de um grupo de células de uma tabela, definida pelos atributos de escopo e cabeçalho.
<tbody> <tbody> - Elemento que encapsula um conjunto de linhas de uma tabela indicando que compõem o corpo da tabela. 
<tfoot> </tfoot> - Conjunto de linhas resumindo as colunas da tabela.
. Inserindo o estilo da tabela criada com CSS.

- Cuidado com a URL no navegador.
. Utilizar o http-server nas aulas seguintes e não o live server, pois o live utiliza a porta 5500 e não a 8080.

- Formulários #01.
. Estrutura do exercício, fazendo uma organização básica sobre formulários.
. Criação uma subpasta e dentro tendo um arquivo server.js e um arquivo .html.
. No arquivo server, ao abrir o terminal será inicializado o arquivo package-json, com a instalação das dependências do express e body-parser.
. No arquivo form.html terá a descrição do formulário em html, tendo as tags com as seguintes propriedades:
<form> </form> - Será uma seção de um documento que contém controles interativos que permitem ao usuário submeter informação a um determinado servidor web.
action="" - Ação de um formulário, é o programa que é executado no servidor quando o formulário é enviado, podendo ser alterada ou definida.
method="" - Define um conjunto de métodos de solicitação para a ação ser executada em um determinado recurso, solicitação podendo ser segura, e armazenável em cache.
<input> </input> - Criação de controles interativos para formulários na web para receber dados do usuário. 
<button> </button> - Representa um botão clicável.
. Configurar o "backend" para receber a requisição do usuário a partir de uma requisição POST.
. Importando o express e o body parser.
. Criação uma requisição para receber o nome do usuário e respondendo caso tenha sucesso o envio.
. Executando através do node o servidor criado a partir do arquivo server.js e criando de uma requisição para porta 3003 para executar e mostrar a entrada dos dados
inseridos do usuário.

- Formulários #02. 
. Aula focando nas tags que são utilizadas dentro de um formulário.
. A tag input possui um atributo password, cujo a propriedade faz com que a senha seja criptografada ao salvar 
de uma forma que não é possível gerar novamente a senha inserida. 
. Inserindo as tags para senha e geração de texto livre para o usuário.
<textarea> </textarea> - Controle de edição gerando uma caixa de texto, útil para o usuário informar um texto extenso em formato livre.
<div> </div> - Utilizado para agrupar elementos para fins de estilos, podendo compartilham valores de atributos.
. Incluindo inputs com o atributos radio que será botões de escolha. 
type="radio" - Botão de escolha, utilizando o atributo value definindo o valor a ser enviado ao back-end.
. Incluindo input de checkbox, que será possível o usuário marcar caso seja necessário.
type="checkbox" - Caixa de marcação definindo um valor a ser enviado ao back-end.
. Utilizando a tag de select tendo um nome e possuindo opções para o usuário escolher, definir sendo enviado para o back-end.
<option> </option> - Utilizado para criar um controle que representa um item dentro de um elemento.
. Aplicando estilo com CSS para os inputs de textarea, radio e checkbox.

- Formulários #03. 
. Como utilizar o mesmo formulário, para incluir ou alterar.
. Ao incluir um botão de alterar, causará uma submissão do que está sendo definido no método o formulário.
. É possível aplicar a action diretamente no botão, a partir de uma propriedade. 
formaction="" - Propriedade responsável por determinar a url e action na tag button declarada. 
formmethod="" - Propriedade relacionada ao método do botão. 
. É possivel criar sendo muito comum um input escondido, que carregará um id e um valor que não será visível para o usuário.
. Criando no server uma nova requisição para o botão de alterar, gerando uma nova mensagem.
. Instalando a dependência do nodemon para ser atualizado todas as alterações durante a aplicação.
. Caso seja mudado o método para GET, os parâmetros serão visíveis na URL da requisição, os dados não serão inseridos no back-end pelo body,
serão pela requisição query string. 

- Imagens.
. Utilizando tag para inserir imagens e figuras, tendo tipos de extesões diferentes de imagens como: JPG, PNG, GIF.
. Desafio para criação de um Slide.
. Criação de um novo arquivo em html para inserir as imagens a partir de um paragráfo. Utilizando o caminho absoluto para inserir as imagens.
<img> - Tag responsável por atribuir imagens a partir da localização informada na propriedade src.
src="" - Será o endereço a fonte da imagem inserida a partir da tag img.
alt="" - Propriedade alternativa exibindo uma mensagem caso a imagem não seja visível.
width="" - Propriedade relacionada a altura da imagem.
height="" - Propriedade relacionada a largura da imagem.
title="" - Título que será visível pelo usuário ao colocar o mouse em cima da imagem.
. Incluindo um gif, sendo um arquivo animado, utilizando a mesma tag, podendo ter as mesmas propriedades.
. Não é necessário, declarar as medidas da imagem, pois poderá deformar a imagem caso não seja as proporções corretas.
. Incluindo uma imagem no formato PNG, o formato PNG possui diferenças do formato JPG, permitindo transparências em partes da imagens.
<picture> </picture> - Utilizando para especificar múltiplos elementos, na tag <source> para um elemento específico. O navegador irá escolher 
a imagem mais adequada de acordo com o layout atual da página, caracteristicas do dispositivo em que será exibido.
<source> </source> - O elemento é utilizado para especificar múltiplos recursos de mídia de elementos <picture>, <audio> ou <video>. Sendo um
elemento vazio. É normalmente usado para disponibilizar múltiplos formatos suportado em diferentes browsers. 
. Aplicando estilos com CSS.
. Incluindo todo o cód em uma div para fazer um slide na proxima aula.

- Desafio Slider #01.
. Aplicando para todos os paragráfos a propriedade absoluta que agrupará todas as imagens.
. Utilizando a tag de script para realizar a movimentação do slide. 

- Desafio Slider #02.
. Continuação do Desafio.
. Implementando a função slider que será a configuração do slide.
. Selecionando os elementos da div com document.querySelectorAll e transformando em um Array com array.from.
Array.from() - Método que cria uma nova instância de um Array quando for passado um array-like ou um iterable object como argumento.
. Criação de uma função para receber a lista de slides e recebendo a função de realizar o movimento. 
innerWidth - Propriedade que retorna a largura interna da janela em pixels. Isso inclui a largura da barra de rolagem vertical, se houver.

- Vídeo.
. Utilizando a tag video.
. Criando um novo arquivo e incluindo o link no index.
<video> </video> - Elemento utilizado para inserir conteúdo de vídeo em um html.
. Sendo possível mencionar a url do vídeo atráves do src ou da tag <source>
<source> </source> - Especifica múltiplos recursos de mídia de elementos, como picture, audio ou video em HTML5.
. Colocando as propriedades de altura e largura.
controls - Propriedade que será mostrado ao usuário os controles de vídeo, dando acesso ao play, andamento do vídeo, volume, tamanho
de tela e opção para download.
autoplay - Propriedade que quando o usuário entre na página automaticamente o vídeo inicia. 
controlsList="" - Propriedade que receberá o atributo que não será incluido na barra de controle do vídeo. 
. Utilizando CSS para estilizar a barra de progresso e os botões.  

- Desafio Controlar Vídeo.
. Utilizando o script para assimilar as divs criadas de controle com o vídeo.
.oncontextmenu - Propriedade do manipulador de eventos da janela para eventos com o botão direito do mouse. Caso seja false, o usuário não tem acesso com o click direito do mouse.
. Utilizando o querySelector para os botões de play e pause, com um evento de onclick que fará com que os botões fiquem associados ao vídeo, podendo retirar o controls.
. Para o progresso será feita uma função setInterval que receberá a div progresso e a div vazia que está contida dentro da div progresso, selecionando a mesma para realizar um 
percentual do vídeo que está passando, fazendo com que mostre o progresso dele e o quanto tempo tem. 

- Tags Não Visuais.
. Tags que não são visíveis no html como div e span.
<div> </div> - Utilizado para criar áreas ou divisões para colocar um agrupamento de elementos dentro de uma tag, podendo aplicar estilos. Aplicado em blocos. 
<span> </span> - Utilizada para criar um destaque ou um estilo diferente, aplicado em linhas. 
<section> </section> - Serve para definir uma seção em um documento, possuindo sempre um título com poucas exceções. 
<article> </article> - Elemento que representa uma composição independente em um documento, página, aplicativo ou site, que se destina a ser distribuído. 
<header> </header> - Representa um grupo de suporte que faz a introdutório ou navegacional, podendo conter também outros elementos como um logo, 
cabeçalho, formulários, pesquisas, entre outros. 
<footer> </footer> - Representa o rodapé para o conteúdo de seção ou seja o rodapé do section mais próximo. 
<nav> </nav> - É uma seção de uma página que encaminha para outra página ou para outras áreas da página, ou seja uma seção de com links de 
navegação.
<aside> </aside> -  Representa uma seção de uma página que consiste o conteúdo que atinge relacionando ao conteúdo do seu entorno.
<details> </details> - Cria um widget de divulgação no qual as informações são visíveis apenas quando o widget é alternado para um estado "aberto". Utilizado para mostrar detalhes 
quando acrescentado.
. Aplicando CSS para div e span.

Seção 14: CSS.

- Avisos sobre o próximo link.
. Link dos arquivos da seção: http://files.cod3r.com.br/curso-web/css.zip

- Baixando o Arquivo Zip.
. Baixando o arquivo e extraindo para a pasta do curso, será utilizado os arquivos em html para apenas incluir o css nas páginas. 

- CSS: Introdução. 
. Cascading Style Sheets - Folha de Estilo que funciona em Cascata.
. Podendo ser aplicada as propriedades a partir de múltiplos códigos em CSS, aplicando em um determinado elemento.
. Dando beleza da parte estética de uma página web, utilizando uma folha de estilo.
@import - É utilizado para importar regras de estilos de outras folhas de estilo, a regra deve preceder em todos os outros tipos de regras.
. O maior padrão, sendo uma boa prática em algumas linguagens será a simplicidade, trazendo uma forma fácil de entender para outras pessoas. 
. No CSS é prioritariamente aplicado estilo utilizando class, podendo aplicar com a tag, com id. Mas o indicado é utilizar a class. 

- Anatomia CSS.
. Modelo de escrita do CSS. 
. Utilzando o arquivo em html de anatomia dentro da tag style será feito o código css.
. É possivel acrescentar um código css inline na própria tag ou até mesmo em um arquivo próprio em css.
. Para iniciar é necessário informar o seletor, podendo ser de vários tipos diferentes, e dentro de { } é informado as propriedades e valores
do CSS. 
. No CSS, é definido algumas propriedades como:
color - Propriedade para aplicar cor podendo ser pré definidas por um valor expresso decimal ou até mesmo pelo nome pré definido
font-size -  Propriedade relacionada ao tamanho da fonte, podendo ser associada a números. 
text-align - Alinhamento do texto ou frase, com valores pré definidos.
. Shorthand Property - É uma possibilidade do CSS associando um valor com múltiplos valores. Por exemplo o valor da borda contém o tamanho a cor e o alinhamento.
border - Borda aplicada permitindo separar um espaço do layout de uma página, definindo onde vai aparecer.
font-family - Lista de prioridades de familias de fontes e/ou nomes genéricos de fontes a serem especificadas para um elemento selecionado.
. Com CSS é possível trabalhar com alternância, por exemplo no caso da font-family, caso não possua a fonte informada instalada no computador, será mostrado com 
a próxima alternativa informada.
. Também é possível envocar funções pré definidas no CSS, uma das funções que podem ser escritas é a função de cálculos, para calcular dimensões.
width - Determina a largura da área de conteúdo de um elemento selecionado.
background-color: rgb(red, green, blue) - Define a cor de fundo de um elemento, com rgb é uma função que indica uma cor obtida com a mistura de uma quantidade red 
para a cor vermelha, green para a cor verde e blue para a cor azul.
. Utilizar uma pseudo-classe, faz com que uma palavra chave especifique um estado especial de um elemento selecionado. Declarado a partir de :
. Um pseudo-elemento faz com que uma palavra-chave seja adicionada a um seletor permitindo que seja estilizado uma parte específica do elemento selecionado. Sendo declarado
a partir de :: 
:hover - Alterar a cor de um botão quando o usuário passar o cursor sobre ele.
::first-letter - Seleciona a primeira letra da primeira linha de um bloco, desde que não seja precedida por outro conteúdo.
. Em CSS o ; é obrigatório para separar as propriedades e os nomes separados serão escritas separados pelo hífen como dash case.
font-weight - Intensidade da fonte, faz com que o elemento selecionado fique definido conforme o valor informado. 

- CSS Interno, Externo e Inline.
. Como aplicar o CSS.
. Existe três maneiras de se aplicar css, sendo externo a partir de um arquivo, ou a partir de uma tag style no diretamente no corpo da página e a partir de uma linha que
está relacionada diretamente dentro de um elemento.
link:css - Maneira de importar o arquivo externo do css, mostrando o tipo de relação e referenciando o arquivo que está sendo ligado com a página.
. O estilo aplicado será o que estiver em primeiro na documentação do css podendo ser um link referenciado ou até mesmo a tag style.
. Para utilização do css Inline, pode ser incluido na própria tag, com a propriedade style, não sendo recomendado utilizar o método Inline, devido ocorrer alterações durante 
criação.

- Criando a Class .tag.
. Arquivos implementados para criar a classe .tag.
. Elementos que possuem a mesma classe declarada como tag, utilizando o arquivo e com o javascript em outros exercícios, será feito um código para mostrar como os componentes 
estão dispostos na tela.
padding - Define a distância entre o conteúdo de um elemento e suas bordas.
margin - Propriedade que define a área de margem nos quatro lados do elemento.
margin-left - Define as dimensões da margem esquerda.
. Para comentar uma linha basta inserir /* Comentário.  */ 
. Utilizando o JS, para cada elemento, apareça o nome da tag associado a cada elemento informardo no html, selecionando com querySelector e 
ultilizando forEach para percorrer nos elementos.
. Criando uma constante que recebe o nome da tag e sempre minúsculas, após isso fazendo com que os elementos receba uma cor na borda #616161.
. Utilizando uma estrutura If para receber a tag se estiver contido o 'nolabel', caso não tenha a classe CSS que seria o box do elemento, será criado um para os elementos.
.classList - Propriedade que realiza a leitura e retorna uma coleção DOMTokenList, ativa dos atributos de classe do elemento.
document.createElement - Cria um elemento HTML especificado a partir de um código JS.
. E aplicando estilo ao label, no arquivo css.
vertical-align - Alinhamento vertical de um elemento html.
margin-right - Define as dimensões da margem a direita.
padding - Define uma distância entre o conteúdo de um elemento e suas bordas.

- Seletores CSS #01.
. O CSS possui alguns seletores, para aplicação de estilo, trazendo diversas maneiras de aplicar e selecionar o elemento desejado.
* - Seletor padrão, aplicando a uma determinada propriedade a todos os elementos. 
ELEM - Utilizando o próprio elemento para aplicar estilos, por exemplo, dentro de uma tag div, h1, entre outros. 
.class - Seletor class que é possível reutilizar em outros elementos que são da mesma class, aplicando uma class em uma tag. A class é uma propriedade muito específica sendo projetado para ser um dos caminhos mais seguros.
#ID - Seleciona os elementos a partir de um ID.
[Atrib] - Seletor a partir de um Atributo, que também é possível aplicar estilos com CSS.
:pseudo-class - Seletor que especifica um estado especial do elemento selecionado.
:pseudo-elementos - É um seletor que permite que seja estilizado uma parte específica do elemento selecionado.
. Trabalhando com seletores, é possível realizar combinações. Existem métodos diferentes para se combinar os seletores. Sendo:
Seletores Descendentes - Correspondendo a qualquer elemento que tenha um descendente que estará dentro desse elemento.
Seletores Descendentes Diretos - Corresponde a qualquer elemento que seja direto como descendente do elemento.
Seletores Irmão - Corresponde quando um elemento é precedido por um outro elemento.
Seletores Irmão Adjacente - O seletor corresponde e se compartilham da mesma origem precendendo imediatamente.

- Seletores CSS #02.
. Utilizando o arquivo seletores.html para aplicar estilos usando seletores que foram informados na aula anterior.
. Para utilizar um seletor descendente direto, basta inserir o Seletor > descendenteDireto, por exemplo: #aninhado > div {}.
. Para selecionar umm seletor irmão é necessário utilizar o ~ , por exemplo p ~ ol {}. Será selecionado a ol que está após os itens abaixo de p.
. Para utilizar o seletor a partir de um atribut, basta inserir o atributo entre [].
:nth-child() - Seleciona elementos com base em suas posições em um grupo de elementos irmãos.

- Especificidade CSS #01.
. Ordem que um determinado seletor será aplicado na página.
. A especificação é a maneira de como os navegadores definem quais valores de propriedades são os mais relevantes para o elemento a ser utilizado.  A especificação é baseada apenas nas regras impostas na 
composição de diferentes tipos de seletores. Por exemplo: Seletores específicos.
!important - Regra utilizada na declaração de estilo que substitui qualquer outra declaração feita no CSS. Não é uma especificidade mas a ultrapassa, então não é recomendado ser utilizado.
. O nível de especificidade faz com que seja aplicado o estilo no elemento que for mais especificado.

- Especificidade CSS #02.
. Continuação dos exercícios de especificidades nos arquivos em html.
https://specificity.keegan.st/ - Calculadora que calcula a especificidade dos componentes do CSS.
. Caso os estilos sejam de diferentes pesos são aplicados ao mesmo elemento, o estilo que estiver com maior peso será o aplicado, se estiverem com o mesmo peso, os estilos que vierem mais abaixo serão 
aplicados, devido ao efeito cascata.
. A especificidade é calculada da seguinte forma:
O seletor universal é ignorado.
Número de IDs em cada seletor.
Número de seletores de classes, atributos e pseudo-classes.
Número de seletores de tipo pseudo-elementos e elementos.
Estilos Inline tem a maior prioridade que todas as condições.

- Herança. 
. Por conta do CSS ser aplicado em cascata, faz com que determinados estilos de um atributo sejam transmitidos para outros atributos.
https://fonts.google.com/ - Fontes, para utilizar nos exemplos e exercícios.
inherit - Para herdar uma propriedade que não vem por padrão por herança.

- Box Model #01.
. Presente em quase todos os elementos do HTML e CSS.
. É um módulo de CSS que define caixas retangulares incluindo o preenchimento e margem que são gerados por elementos dispostos de acordo com o modelo de formato visual.
. Possuindo quatro propriedades que se relacionam para compor a dimensão do elemento. 
Content - Conteúdo que está sendo trabalhado.
Padding - Espaçamento que não é obrigatório a ser informado todas as dimensões.
Border - Borda, podendo ser ou não aplicada.
Margin - Margem será o espaçamento entre os componentes.
. A propriedade padding possui alguns shorthand, que faz com que a propriedade aplique o padding em todas as dimensões. Pondendo ser um único valor para todas as dimensões,
dois valores que será aplicado no eixo vertical e horizontal e quatro valores que será para as quatro dimensões. Sendo aplicado no sentido horário: Em cima, direita, abaixo
e esquerda.
. E será da mesma maneira ao aplicar Margin.

- Box Model #02.
. Utilizando o arquivo box.html, para aplicar CSS utilizando os métodos da aula anterior.
float - Determina que um elemento deve ser retirado do seu fluxo normal e colocado ao longo do lado direito ou esquedo do seu conteiner, então os textos e elementos em linha 
irão se posicionar ao seu redor.

- Margin Collapse.
. Um comportamento que ocorre em três tipos de casos:
Irmãos Adjacentes: Quando as margens de irmãos adjacentes são colapsadas.
Pai e primeiro/último filho: Caso não possua border, padding, parte inline, criado para separar a margin-top de um bloco, as margens se colapsam.
Bloco Vázio: Caso não possua border, padding, conteúdo inline, height ou min-height, para separar um bloco margin-top de sua margin-bottom, então as margens superior e inferior 
são colapsadas. 
. Ocorrem quando os casos acima são combinados, essa regra se aplica até mesmo para as margens que são zero.

- Propriedade Display.
. Propriedade display que permite definir a maneira como determinado elemento html deverá ser renderizado.
. Possuindo diversos tipos diferentes de exibição de caixa, o valor none permite ativar a exibição de um elemento, quando é utilizado o valor, os elementos descendentes também terão 
a sua exibição desativada. O documento é renderizado como se o elemento não existisse na árvore do documento.
display: none - Retira o elemento do layout da página.
display: inline - Faz com que o elemento HTML seja renderizado inline, dentro do bloco na mesma linha.
display: block - Define um bloco contendo um espaço em branco tanto em cima como embaixo e não permite outros elementos ao lado, exceto quando tiver sido declarado ao contrário.
display: list-item - É exibido com as características de um item de uma lista, podendo ser utilizado em conjunto com as propriedades list-style-type e list-style-position.
display: inline-block - Um bloco inline, ou seja, na mesma linha do conteúdo adjacente. Mas comporta-se como um bloco.

- Inline-block: Comportamento Estranho.
. Ao utilizar o display: inline-block. Exemplo com o menu principal no arquivo index.html.
. Atenção ao espaços em brancos que serão considerados ao inline-block, podendo ter alterações no design da página.
. Caso seja necessário retirar os espaços em branco, é necessário acrescentar um comentário entre as tags.

- Altura & Largura.
. Utilizando o arquivo alturaLagura.html, para aplicar os estilos durante o exercício.
. Para todas as tags e atributos que são inline, faz com que seja desconsiderado altura e largura. Apenas sendo possível altera-las em pixels.
. Caso o tamanho seja em percentual, será considerado o padding da página, então o comportamento padrão altura percentual só irá fazer diferença de acordo com a altura do padding.
. Por padrão a tag body e a tag html tem a altura equivalente ao tamanho dos elementos. 
. Tamanhos absolutos fazem com que body e o html cresça, tamanhos relativos terá que ter mais atenção e colocar os percentuais até alcançar o html para que tenha
espaço.
. Display inline não é considerado a altura e largura, display block ou inline-block será considerado. 

- Box Sizing.
. Propriedade importante para entender como o tamanho do Box Model é calculado, existindo duas váriações que será ressaltado na aula.
. Utilizando o arquivo em HTML, e inserindo os estilos css.
. Para fazer com que a borda do elemento seja considerado como o tamanho que foi informado, basta utilizar a propriedade box-sizing.
box-sizing: content-box - O padding e a border não serão considerados para gerar o box, então o tamanho será definido pelo conteúdo apenas.
box-sizing: border-box - As propriedades de width e height incluem o tamanho do padding e a border, Fazendo com que seja gerado o box com a borda e o conteúdo do tamanho informado 
sem ultrapassar.
. Não é transmitida por herança. Caso seja solicitado inclui-lo em todas as propriedades, basta utilizar o seletor universal para declara-lo.

- Propriedade Overflow.
. Caso um elemento transborde por outro elemento, é possível utilizar o overflow, sendo uma propriedade que criará um novo contexto de formatação de bloco.
overflow: hidden - O conteúdo que ficará de sobra será cortado e nenhuma barra de rolagem é exibida. Então além do conteúdo do espaço destinado nada será exibido.
overflow: scroll - Será acessível o conteúdo, através de uma barra de rolagem que será exibida mesmo que o conteúdo não precise, evitando problema de barra de rolagem aparecendo e 
desaparecendo quando o conteúdo for dinâmico. (Ao imprimir o conteúdo pode vir a ser vazado).
overflow-x: scroll - Define o que é exibido quando o conteúdo transborda das bordas esquerdas e direita de um elemento de nível bloco. 
overflow-y: scroll - Definido quando o conteúdo exibido transborda bordas superiores e inferiores de um elemento.
. Sendo possível aplicar o overflow-y e overflow-x como hidden para diferentes tratamentos dos elementos.

- Propriedade Float.
. Float que é a determinação de um elemento que faz com que seja retirado do fluxo normal e é colocado ao longo do lado direito ou esquerdo do bloco, dando um aspecto flutuante.
. Flexbox sendo um conceito que auxilia no float visando organizar os elementos dentro de seus blocos de formas dinâmicas.
float: right - Define os conteúdos para direita.
float: left - Conteúdos serão definidos para esquerda.
clear: - Atributo que define as bordas de um elemento que não serão aceitos outros elementos posicionados por float, definindo então quais serão as bordas que ficará livre na 
distribuição visual dos elementos.

- Cores.
. Possibilidades que podem ser utilizadas para selecionar cores no CSS. 
. Sites de referências que será visualizado o padrão de cores.
HSL: Hue Saturation Lightness - Hue é o espectro de cor sendo de 0 a 360, Saturation e Lightness irá de 0 a 100, Saturation no 0 fará com seja uma escala de cinza mesmo se for 
alterado o hue, no caso se colocar próximo ao 100 será uma cor viva, intensa. Lightness será a luminosidade, partir dos 50% deixando mais para o branco ou para o preto.
RGB: - Red, Green, Blue - Utilizando as cores vermelho, verde e azul em diferentes intesidades fazem com que seja criada outras cores. Escala utilizada uma númeração de 0 a 255, 
sendo 0 a total da ausência da cor e 255 a intensidade máxima.
Hexadecimal - Sendo um código iniciado por # consistindo em seis caracteres que podem ser letras e números, cada um dps caracteres do códigos será referente a intensidade de uma 
cor no espectro RGB. Os dois primeiros referentes a vermelho, o terceiro e quarto referentes ao verde e os dois últimos ao azul. A intensidade é medida em uma escala de 00 a FF, 
sendo 00 o tom mais escuro possível e o FF o mais claro.
. Ao acrescentar no final 00 até ao FF em diferentes combinações será possível definir transparência.
RGBA: - Red, Green, Blue, Alpha - Mesma função do RGB, apenas acrescentando o elemento Alpha que é medido uma escala menor que vai de 0.0 a 1.0, sendo 0.0 transparente e 1.0 opaco.
HSLA - Assim como RGBA, tem o atributo Alpha que é adicionado ao código para representar a opacidade em valor de 0.0 a 1.0.

- Unidade #01.
. Unidades importantes para dimensões dos elementos e das fontes utilizadas.
. Possuindo dimensões absolutas, são unidades de medidas definidas pela física, como o píxel, centímetro, metro, etc...
. Principalmente com unidades absolutas no CSS é trabalhado com pixel, uma observação é que 1 pixel no html não significa 1 pixel físico do device. Sendo normalizado e calculado 
dependendo da densidade da tela que está renderizando.
. Não é muito utilizado centímetros ou milímetros, apenas para impressão.
. Então das unidades absolutas a que será mais utilizada será o pixel.
. Outra unidade que é utilizada é o viewport, sendo o tamanho da página visível. Contendo os seguintes valores:
VH VW - Unidades que significam em viewport, sendo o VH para altura e VW para largura, então elas utilizaram o tamanho total da viewport (Tamanho do dispositivo), ou seja, uma altura 
de 100vh corresponde a 100% da página total, do corpo do body.
Vmin Vmax - Utilizarão como base a menor dimensão da viewport.
. Em relação as fontes, são baseadas em unidades absolutas podendo utilizar também fontes baseadas em tamanhos relativos. Tendo:
REM - (root em) É o tamanho de fonte do elemento-raiz do documento.
EM - Será uma fonte que é baseada no elemento-raiz. 
% - O percentual é um caso a parte, sendo um caso especial, servindo para definir as dimensões no viewport, e também para definir as fontes de forma percentual. Mas dependendo do tipo de 
configuração, o percentual fará uma referência ao próprio viewport ou será feito uma referêcia ao elemento-raiz que está dentro, ou irá ou não considerar o padding.

- Unidade #02.
. Aplicação no arquivo html de unidades relativas e absolutas vistas na aula passada.
position - Recurso utilizado para ordenar os elementos HTML de uma página web.
top - Propriedade que indica um espaço acima do elemento.

- Unidade #03.
. Utilizando a largura de um elemento, aplicando com percentuais. 
. Por padrão ao criar uma div a mesma possui a largura 100%, a única coisa que não possui por padrão é uma altura. A altura da div, será assumido a partir de um conteúdo a ser
inserido.
position: static - O elemento será posicionado de acordo com o fluxo normal do documento, propriedades top, right, bottom, left e z-index não possuem efeitos, tornando o valor padrão.
position: relative - O elemento será posicionado de acordo com o fluxo normal do documento e será deslocado em relação a base de valores de top, right, bottom e left.
position: absolute  -  O elemento é removido do fluxo normal de documentos e nenhum espaço é criado para o elemento no layout da página. Posicionando ao seu ancestral mais próximo, se 
houver relação, caso contrário é colocado em relação ao bloco contendo inicial, definido em sua posição final pelos valores de top, right, bottom e left. 
position: fixed - O elemento é removido do fluxo normal de documentos e nenhum espaço é criado para o elemento no layout da página, sendo posicionado em relação ao bloco estabelecido pelo 
viewport inicial, exceto quando seus ancestrais possuem uma propriedade transform, perspctive ou filter definido como algo diferente de none. 
. Ao utilizar percentuais na altura e largura, depedendo das possibilidades nas combinações das propriedades pode ocorrer distorções devido a position do elemento.

- Texto. 
. Propriedades para trabalhar com textos, com o arquivo texto.html.
. Utilizando a propriedade font-size com os valores padrões, unidades absolutas e unidades relativas.
font-size: 1em; - Esse valor faz com que a fonte tenha um tamanho padrão.
font-size: 100%; - O uso desse valor faz com que a fonte que permaneça no valor declarado.
font-size: 16px; - Valor fixo declarado em pixels 
font-size: 12pt; - Valor de pontos que é equivalente a 16px e também e equivalente a 100%.
font-family - Lista de prioridades de familias de fontes e/ou nomes genéricos de fontes a serem especificadas para um elemento selecionado.
font-weight - Intensidade da fonte, faz com que o elemento selecionado fique definido conforme o valor informado. 
font-style - Define se uma fonte deve ser estilizada com uma face normal, itálica ou olíqua de seu estilo. 
text-transform - Propriedade que especifica como capitalizar o texto de um elemento. Possuindo valores:
text-transform: capitalize - Converte a primeira letra de cada palavra em maiúscula.
text-transform: uppercase - Converte todos os caracteres em maiúscula.
text-transform: lowercase - Converte todos os caracteres em minúsculos.
text-transform: none - Impede que todas as maiúsculas e minúsculas de todos os caracteres sejam alterados. 
word-spacing - Define o comprimento do espaço entre palavras e entre tags.
letter-spacing - Propriedade que define o comportamento do espaço horizontal entre os caracteres de texto.
line-height - Define a altura de uma caixa de linha. Normalmente utilizado para definir a distância entre as linhas de texto.
text-decoration - Define as aparência das linhas decorativas no texto. 
. Definindo um estilo para o botão, com as propriedades de tamanho, cor, efeitos e entre outras propriedades. 
border-radius - Propriedade que arredonda os cantos da borda externa de um elemento. 
box-shadow - Adiciona efeitos de sombra ao redor do quadro de um elemento. 

- Propriedade Position.
. Como utilizar o position, saber como posicionar os elementos, e como um elemento influencia na posição do outro. 
. Estilizando o arquivo position.html.
. Utilizando sa propriedade position com os valores: fixed, absolute, relative.
position: sticky - Elemento que é posicionado de acordo com o fluxo normal do documento e, em seguida, deslocado em relação ao ancestral de rolagem mais próximo e contendo bloco. 

- Media Query.
. Utilizando o arquivo mediaQuery.html.
. Consistindo em um media type, com pelo menos uma expressão que limita o escopo da folha de estilo. 
. Utilizando o media features, tal como largura, altura e cor adicionadas no css. 
. Deixando a apresentação do conteúdo adaptado a uma gama específica de dispositivos não precisando mudar o conteúdo em si.
. Para definir uma página a diversas resoluções de dispositivos é nescessário utilizar responsividade, fazendo com que o site se comporte de diferentes formas dentro do contexto
de orietações para paisagens ou retrato.
. O css possui frameworks que traz a responsividade de forma mais pronta, um exemplo é o bootstrap sendo um dos mais conhecidos do CSS.
. Ao trabalhar com esse conceito adaptando para o elementos faz com que seja melhor a visualização em diversos tipos de dispositivos, fazendo com que o site fique responsivo.
@media () - Para definir os critérios que será ou não aplicado para definir o que está dentro. 
min-width | max-width - Define a largura mínima e máxima que o elemento irá possuir, e a partir de seu valor declarado será a resolução do elemento na página.
orientation - Recurso de mídia que poderá ser utilizado para testar a orientação da janela de visualização.

- Desafio Menu #01.
. Com o arquivo desafioMenu.html, para criação de estilos com CSS.
. Menu do site Cod3r.

- Desafio Menu #02.
. Dicas para realizar o Desafio Menu Cod3r.
. Utilizando JS para criar uma função recebendo um evento de click selecionado para os elementos do menu.
.onhashchange - Evento que será disparado quando uma determinada parte do link muda. Chamando uma determinada função para ser executada.

- Desafio Card #01.
. Desafio de criação de dois cards.
. Arquivo desafioCard.html.

- Desafio Card #02.
. Dicas para realizar o Desafio.

- Flex Box vs CSS Grid.
. Conteúdos Finais do Capítulo de CSS.
. Flexbox e CSS Grid são duas tecnologias muito utilizadas no CSS, trazendo aderencia para os browsers.
. Trazendo uma forma melhor para fazer os layouts e a utilização do css.
. Sendo duas tecnologias nativas do css, trazendo compatibilidade para diversos tipos de browser, e que se complementam.
. O flex box seria a melhor tecnologia para aplicar layout.
display: flex; - Utilizado para o flex box e definindo a orientação que será trabalhada, porque o flex box é unidimensional operando em uma única linha
ou coluna. | display: flex - Elementos se comportam como um elemento de bloco e apresenta seu conteúdo de acordo com o modelo flex box.
. CSS Grid já atua como uma forma bidimensional, ou seja algo de fato como grid, possuindo linhas e colunas, e organizando a aplicação com CSS Grid.
. Grid é muito utilizado para analisar o layout macro da aplicação. 
display: grid - Define os elementos como grade. 

- Flex Box Nomenclatura. 
. Os elementos do CSS são trabalhados em caixas, podendo colocar um dentro do outro, quando é declarado o display para flex, os elementos passa
a ser flex box, então o elemento passa a ser um flex contênier. 
Flex Contênier - Tem o objetivo de agrupar e armazenar dentro os flex itens.
Flex Item - Será transformados os items após ser declarado com display.
. Sendo unidimensional, terá como eixo principal a linha ou a coluna, quando é definido o eixo principal, o outro será o eixo alternativo ou secundário 
chamado Cross Axis.
Main Axis - O principal eixo a ser trabalhado podendo ser linha ou uma coluna.
Cross Axis - Eixo secundário ou alternativo. 
Main Size - Sendo o tamanho do Main Axis.
Main Start | Main End - Os flex itens são inseridos começando pelo Main Start atpe chegar ao Main End. 
Cross Size - Mesmas funções do main size.
Cross Start | Cross End - Mesma função do main start e main end.
Main Dimension - Será a altura e a largura dos flex items.

- Flex Box #01.
. Utilizando o arquivo flexbox1.html.
flex-direction - Define os itens flexíveis, colocando no contênier flexível, definindo o eixo principal e a direção, definidas como:
row | row-Reverse - Valor que se refere a linha, sendo eixo principal moverá ao longo da linha todos os flex items na direção inline.
column | column-Reverse - Valor que se refere a coluna, e o eixo sendo principal se moverá do topo até o fim da página na direção block.
flex-wrap - Define se os itens flexíveis serão forçados a ficarem na mesma linha ou se podem ser quebrada em varias linhas. Caso seja valido, os define 
na direção em que as linhas são empilhadas. 
wrap - Os itens flexíveis será quebrado em multiplas linhas.
nowrap - Os itens flexíveis serão agrupados em uma única linha, podendo fazer com que o flex conteiner transborde. 
wrap-reverse - Comporta-se da mesma maneira que o wrap, mas a de linha ocorre na direção contrária, ou seja, para a linha acima.
flex-flow - Propriedade que é a junção das propriedades flex-direction e flex-wrap. 
justify-content - Propriedade que serve para alinhar os elementos ao longo do eixo principal, cuja a direção é definida a partir da propriedade flex-direction.
flex-star - Valor que alinhara os elementos rente à borda esquerda do conteiner.
flex-end - Resulta em um alinhamento oposto ao flex-start.
center - Alinha os itens ao centro.
space-between - Utilizado para ocupar todo o espaço livre após a disposição dos itens e dividí-lo igualmente entre os itens. 
space-around - Gera uma quantidade igual de espaços à direita e à esquerda.
align-items - Propriedade que é utilizada para centralizar e alinhar os itens.
stretch - Controla o alinhamento do eixo transversal.
baseline - Os itens são alinhados a partir da base da primeira linha de texto de cada um.
align-content - Propriedade que alinha as linhas de um conteiner flex quando há espaço extra no eixo cruzado, ou seja, não tem efeito algum dentro dos itens 
de uma única linha.  

- Flex Box #02.
. Utilizando o arquivo flexbox2.html
order - Define a ordem para colocar um item em um conteiner flexível ou de grade, são classificado por valor de ordem crescente, e em seguida pela ordem do código-fonte.
align-self - Propriedade que estabelece o alinhamento de um certo item dentro do bloco que o contém, em Flex Box controla o alinhamento dos itens em Cross Axis.
flex-grow - Propriedade que define a largura do elemento em relação aos outros elementos do mesmo conteiner. Caso tenha apenas um elemento, irá ocupar a largura toda, pois
não há com quem ser comparado.
flex-shrink - Define a proporção com que um item deve encolher caso seja necessário. Propriedade que aceita apenas valores positivos, sendo o valor padrão 1.

- Flex Box #03.
. Utilizando o arquivo flexbox3.html.
flex-basis - Define o tamanho inicial que um item deve ter antes que o espaço ao seu redor seja distribuido, ou seja, dependendo da direção do eixo principal. Essa propriedade
define a largura ou altura mínima do elemento antes que ele seja redimensionado por outras propriedades.
flex - Propriedades shorthand, utilizada para fazer abreviação das propriedades grow, shrink e basis.

- Desafio Menu (Flex Box).
. Utilizando o arquivo flexboxMenu.html.
. Organizando os elementos usando o flexbox. 

- Resumão Flex Box.
. Técnica muito utilizada no css, tendo o princípio por trás de como se faz o design ou organização de componentes visuais no Flutter, e também como se faz o layout na web.
Existindo um outro recurso moderno que é o CSS Grid, mas tem ainda algumas limitações que não é possível colocar um grid dentro de outro, diferente do flex box que é possível,
e por isso, por ser um conceito tão popular o Flex Box é aplicado no Flutter, e em outros ambientes que esteja desenvolvendo com Web.
. O flex box possui dois eixos, o eixo principal Main Axis, e o eixo que corta o eixo principal que é chamado de Cross Axis.
. Utilizando a propriedade flex-direction para mudar o padrão do eixo, sendo o padrão da web a linha (row), e para dispositivos móveis coluna (column). A propriedade possui quatro
valores, sendo: row ou row-reverse e column ou column-reverse.
. A propriedade justify-content fará com que seja alinhado os itens no eixo principal (main axis), podendo alinhar os itens contidos na row | column no inicio, ou no centro ou 
com um espaçamento entre cada os elementos, ou com espaços entre e ao redor dos elementos e também é possivel apenas alinhar no final. Não mudando a ordem dos
itens.
. O align-items será a propriedade que alinhará os itens no Cross Axis, tendo os alinhamentos em início ou fim ou no centro do Cross Axis, também possuindo os valores de esticar os itens
para ocupar todo o espaço, e o alinhamento em base do texto que é composto os itens. 
Extensão do Google: Grid Ruler.
. Align-self, sendo a propriedade que estará dentro de cada um dos itens de um flex conteiner, então para fazer o alinhamento de um único item será utilizado essa propriedade. O align-self
se sobrescreve em align-items, então ao declarar será priorizado.
. Flex-grow, flex-shrink e flex-basis, podem ser abrevidas apenas pela propriedade flex, declarando os valores na seguinte ordem: grow, shrink e basis. Então serão as proporções de tamanho
dos itens.
. Para executar o projeto basta instalar as dependências.

- CSS Grid #01.
. Sendo um dos recursos mais novo do CSS3, suportado por vários tipos de browsers a partir de 2017. 
. Introduz um sistema bi-dimensional de grid para CSS. Grids podem ser utilizadas para o desing de layouts de grandes seções de uma página web, assim como de pequenos elementos de interface.
https://caniuse.com/#feat=css-grid - Estatística de como diferentes tipos de browser suporta.
. Diferente do flex box não possui o direcionamento, formada pela interseção de um conjunto de linhas e colunas. Dentrp de um grid, respeitando-se a configuração criada pela suas linhas, podendo
inserir elementos de marcação. 
. Podendo definir as dimensões fixas do grid em pixels, ou grids com dimensões flexíveis definindo-as com uso de porcentagem ou com fração.
. A unidade fr ajuda a criar layouts flexíveis, representando uma fração do espaço disponível do conteiner do grid.
display: grid | display: inline-grid- Para criação de um grid conteiner.
grid-template-columns - Define a dimensão das colunas do grid.
repeat() - O primeiro valor será o número de colunas que a grid será definida, e em seguida os tamanhos que irá possuir.
grid-template-row - Propriedade que define a dimensão das linhas do grid.
. As propriedades grid-template-column e grid-template-row podem ser especificadas como uma palavra chave, ou um valor, ou valores que irão correponder a um ou mais elementos composto na grid.
. Caso não seja declarado os valores para todos os elementos o browser irá utilizar o tamanho necessário para os elementos.
. No browser Firefox ao utilizar a inspecionação do layout da página, existe uma seção Grid, que é possível inspecionar o grid que contém na página.
grid-column-start - Define a posição inicial e um item dentro da coluna do grid.
grid-column-end -  Propriedade que define um elemento na posição final do grid dentro da coluna, contribuindo com uma linha, extensão ou nada, para seu posicionamento.
grid-row-start | grid-row-end - Tem a mesma funcionalida porém será para os elementos que estão em linha. 
z-index - Propriedade que específica a ordem de uma pilha de elementos que está sobrepondo outro, um elemento que estiver com o número maior na ordem de empilhamento será exibido à frente de outro.

- Atualização - Propriedades CSS Grid obsoletas.
. Algumas propriedades do CSS serão utilizadas na próxima aula, incluindo essas três: gridcolumn-gap, grid-row-gap ou grid-gap.
. Recentemente, o uso delas se tornou obsoleto, o que pode gerar o aviso Property is obsolete. Avoid using it (propriedade obsoleta. Evite usá-la).
. Para solucionar isso:
grid-column-gap, utilize column-gap. 
grid-row-gap, utilize row-gap. 
grid-gap, utilize gap.
. Em outras palavras, basta remover o prefixo grid- que funcionarão como esperado.
. Para executar o projeto basta instalar as dependências

- CSS Grid #02.
. Utilizando as propriedades na aula passada.
. Ao declarar as propriedades do grid é possível colocar um nome na linha, para isso basta colocar o nome entre [].
. O nome pode ser utilizado para informar o valor para outro elemento que esteja no mesmo arquivo.
. Também é possível declarar mais de um valor com o shorthand, para isso será inserido uma / entre os valores. 
grid-column-gap | grid-row-gap | grid-gap - Atalho para declarar duas propriedades em um só lugar, caso passe um único valor, os dois serão aplicados para o espaço
para linhas e colunas. Se passar dois valores, o primeiro será para linhas e o segundo para colunas.

- CSS Grid #03.
. Alternativas de organização dos elementos, sendo uma forma mais didática.
grid-template-areas | grid-area - Propriedade que específica o tamanho e a localização que o elemento irá ficar dentro de um grid.
grid-gap - Atalho para declarar duas propriedades em um só lugar, caso passe um único valor, os dois serão aplicados para o espaço
para linhas e colunas. Se passar dois valores, o primeiro será para linhas e o segundo para colunas.
span - Para que um elemento utilize mais de uma célula, basta acrescentar span e o valor.

- Recursos.
. Arquivo PDF Aulas CSS. 

Seção 15: Integrando HTML, CSS e JS.

- Baixando o Arquivo Zip.
. Baixando o arquivo e extraindo para a pasta do curso, será utilizado os arquivos em html, css e js.
. Intregação principalmente em HTML e JS, mas utilizando o CSS. 
. Conceito da DOM, e manipulação desse conceito. 

- O que é DOM ?
. DOM (Document Object Model) - Modelo de Objeto de Documentos representando uma estrutura do documento HTML e o relacionamento entre os elementos (TAGs).
. Quando o HTML é renderizado pelo browser é criado a estrutura em árvore que são os elementos, e a DOM vai facilitar viabilizando para leitura e manipulação 
de forma eficiente com objetos, elementos e atributos. 
. Facilitando a manipulação da página html sem precisar utilizar o parser nas strings. Criando uma estrutura de objetos, um objeto dentro do outro sendo 
possível navegar na API.
. Então a integração das três tecnologias será voltado para o aprendizado de manipulação da DOM.

- Selecionando Elementos #01.
. Formas de selecionar elementos dentro de uma página, utilizando a DOM.
. Selecionando com algumas funções em JS a partir da DOM.
getElementById() - Função do JS que retorna um elemento do DOM, identificado por um ID específico.
getElementsByTagName() - Método que retorna um HTMLCollection de elementos com o nome da tag fornecida. 
dir() - Função do console do browser para obter a lista dos elementos de uma tag especificada, inspecionando as informações de 
herança que o elemento contém.
. Podendo também utlizar o Array.from, com forEach, que percorrerá os elementos.
classList - Propriedade para leitura que retorna uma coleção DOMTokenList, ativa dos atributos de classe do elemento. É uma maneira de acessar a lista de classes
de um elemento. 
getElementsByClassName() - Será uma lista do HTMLCollection de elementos encontrados a partir das classes.
. Quando utilizada a função getElements não é necessário informar o ID com #, sendo mais flexível ao utilizar. 

- Selecionando Elementos #02.
. Utilizando duas funções querySelector e querySelectorAll. É bastante parecida a forma de selecionar elementos dentro do jQuery. 
querySelector() - Retorna o elemento a partir de um ID. Recebendo a partir de um seletor. 
querySelectorAll() - Recebe um argumento de string contendo um seletor CSS e retorna um objeto NodeList representando os elementos do documento que correspondem  
ao seletor.
:nth-of-type - Seleciona os elementos que correspondem a um type, baseado na posição entre o grupo de elementos.

- Selecionando Elementos #03.
. Selecionar elementos em fomulários. 
document.forms - Seleciona os formulários e será uma lista do HTMLCollection contendo os formulários que a página possui.
. Também é possível selecionar a partir de um array.
getElementByName() - Retorna uma coleção de elementos em uma NodeList, atualizando automaticamente com novos elementos com o mesmo nome 
que são adicionados e removidos do documento. 
document.nome - Retornará o elemento formulário que possui o nome que é informado após o ponto.

- Selecionando Elementos #04.
. Como navegar dentro de um elemento que está dentro de outro, navegando pela DOM.
. Declarando uma função para facilitar o console.log utilizando prototype. 
HTMLCollection - Representa um objeto semelhante a um array com elementos na ordem que esta declarado no HTML, oferecendo métodos e propriedades para selecioná-los. 
HTMLElement - Representa os elementos de um documento em HTML, como body, table, form entre outros. 
NodeList - É um objeto semelhante a um Array, porém são objetos retornados pelos métodos Node.
parentNode - Retorna um parente de um elemento no caso o node parente do node referenciado.
childNode - Retorna os textos herdados de um elemento.
firstChild - Propriedade que retorna o primeiro texto.
nextSibling - Retorna o texto seguinte ao especificado em childNodes.
lastChild - Representa o último texto que é herdado do elemento declarado.
previousSilbling - Retorna o textoelemento anterior. 
children - Retorna uma coleção com todos os elementos que são herdados de um elemento HTML pelo qual é chamado. 
firstElementChild - Propriedade que retorna o primeiro elemento.
nextElementSibling - Retorna o elemento seguinte ao especificado em NodeList.
previousElementSilbling - Retorna o elemento anterior.
lastElementChild - Representa o último elemento que é herdado do elemento declarado.

- Acessando Atributos #01.
. Para acessar os elementos com querySelector:
('nome') - Seleciona uma Tag.
('.nome') - Seleciona uma classe.
('#nome') - Seleciona um ID.
('[nome]') - Seleciona uma propriedade. 
getAttribute - Retorna um atributo que uma propriedade específica de um elemento, caso não possua o valor retornado será null ou uma string vazia. 
. É possível acessar diretamente o atributo, referciando a tag e a partir de um ponto.
. Também sendo possível localizar o atributo informando em colchetes [] como um formato parecido com array.
. Além dos atributos que são acessíveis definidos dentro de uma Tag, também possui atributos que são implícitos, todos os elementos e propriedades possuem também.
nodeType - Propriedade de leitura de uma Node interface, sendo um número inteiro que identificando quais são os elementos representados por tags.
https://www.w3schools.com/jsref/prop_node_nodetype.asp - Quais são as descrições dos valores do nodeType. 
node.Name - Propriedade que retorna o nome do elemento ou atributo que está sendo acessado a partir dessa propriedade. 
getAttributeNode() - Retorna o atributo especificado do elemento acessado.
nodeValue - Conjunto de propriedades que retorna o valor do elemento do elemento específicado, podendo alternar o valor. 

- Acessando Atributos #02.
. Continuação do conceito de acessar os atributos e propriedades.
hasAttribute() - Propriedade que verifica se à um atributo no elemento. 
setAttribute() - Adiciona um novo elemento ou modifica o valor de um atributo existente em um elemento específicado.
removeAttribute() - Remove um atributo com o nome do local e o URI de namespace especifícados, caso o atributo removido tiver um valor padrão, será substituído.
dataset - Retorna o nome do atributo sem o hífen - , sendo possível adicionar dados a elementos html como se fossem constantes. 
. Nem sempre o atributo que esta definido no html nem sempre esta disponível para acessar com o mesmo nome.
. Atributos que são do HTML é acessível a partir da notação ponto, atributos que personalizados é necessário acessar a partir do getAttribute.
htmlFor - Retorna ou define um valor do atributo for de um rótulo. O atributo for especifica a qual elemento de formulário um rótulo está vinculado.

- Acessando Atributos #03.
. Forma de apenas leitura dos valores dos elementos 
attributes - Retorna uma coleção de todos atributos registrados de um elemento específicado. É possível utilizar a propriedade para localizar os atributos a partir de 
um id, notação ponto ou uma string entre colchetes quando o atributo estiver hífen. 

- Acessando Classes.
. Acessando elementos a partir de classes. 
classList - Propriedade para leitura que retorna uma coleção DOMTokenList, sendo uma maneira de acessar a lista de elementos de uma classe declarada.
add - Adiciona o token que estiver em ('') a lista de classes.
remove - Remove o token que estiver em ('') a lista de classes.
toggle - Método que remove caso tenha um token existente na lista, caso não exista será adicionado um novo.
contains - Verifica se o elemento está contido ou não dentro da lista.
length - Quantidade de classes que um elemento possui.

- Modificando HTML #01.
. Como modificar a DOM, principalmente inserindo novos elementos na página.
. Ao ser criada um novo elemento, é possível adicionar classes, atributos, e outras definições que são possíveis a um elemento em HTML.
createElement() - Cria um elemento HTML especificado.
setAttribute() - Adiciona um novo elemento ou modifica o valor de um atributo existente em um elemento específicado.
appendChild - Método fundamental usando o DOM, insere um novo nó na estrutura do DOM de um documento, podendo criar, adicionar elementos. 
createTextNode - Cria um nó de texto e auxilia na criação de um elemento DOM.
insertBefore - Insere um nó antes do nó referenciado.
cloneNode - Duplica um elemento node (nó), na estrutura de um documento DOM.
removeChild - remove um nó filho do elemento DOM.

- Modificando HTML #02.
. Inserir elementos dentro de outro elemento.
innerHTML - Substitui todo o valor informado ao ser declarado em um elemento selecionado.
innerText - Mostrará o texto associado ao valor do elemento.
outerHTML - Tanto o conteúdo externo como interno será substituido o valor ao ser declarado. 
insertAdjacentHTML - Analisa o texto e insere um valor que será em uma posição especificada.

- Trabalhando com Eventos #01.
. Quando a uma integração entre HTML e JS um dos aspectos mais importantes é como o tratamento de eventos se realizam, como um click de um link, ou de um botão
o submit de um formulário.
. Um dos padrões é o web-server, é um dos padrões mais utilizados na web. Tendo uma operação assíncrona, e quando um determinado evento ocorre, é invocado o observer
para fazer o tratamento nos eventos que aconteceram.
. Utilizando o arquivo em HTML com o propósito de interceptar o click, para que uma função faça o click.
preventDefault() - Evita o comportamento padrão de um elemento.
window.location.href - Será uma string com a URL completa do site atual.
. Ao utilizar o onclick, para quem ler o código ficará explicitamente visível o código e a função criada.
. Uma das melhores maneiras de trabalhar com onclick é criando uma propriedade específica.
onclick - Executa determinada funcionalidade quando um botão do mouse é clicado.

- Trabalhando com Eventos #02.
. O princípio por trás do tratamento de eventos é praticamente o mesmo. A mecânica em si do tratamento geralmente é em um padrão observer.
. Utilizando o arquivo em html, o próposito do exercício será um click na div e movimentar o elemento que contém na tela.
onmousemove - Evento que ocorre semmpre que o ponteiro do mouse se movimentar dentro de um elemento div.
style.cursor - Específica o cursor do mouse quando o ponteiro está sobre um elemento.
style.position - Referencia o posicionamento do elemento. 

- Trabalhando com Eventos #03.
. Como implementar um Drag and Drop (arrastar e soltar) em um elemento de um lugar para o outro.
draggable - Representação de elementos arrastáveis, seguem o ponteiro do mouse durante a operação drag (arrastar).
ondragstart - Será acionado o evento quando o usuário começa a arrastar os elementos. 
e.target - Propriedade a qual mencionada faz a referência ao objeto para qual evento foi enviado. 
dataTransfer.setData - O objeto dataTransfer será utilizado para guardar os dados que estão sendo arrastados durante uma operação de Drag and Drop
ondragover - Ocorre quando o elemento é arrastado sobre o lugar alvo.
ondrop - Ocorre quando o usuário termina de arrastar o elemento e é solto sobre o destino.
preventDefault - Cancela o evento caso seja cancelável, sem parar a propagação do mesmo.

- Trabalhando com Eventos #04.
. Existem diversos tipos de eventos dentro do html. Retomando as aulas passadas foram vistos os eventos:
Evento de click.
Evento de mouse alternativos.
Evento drag and drop.
. E para finalizar sobre trabalhar com eventos, o exercício sera de como interceptar o evento de submit de um formulário.
formData() - É criado um novo objeto formData.
formData.append - Acrescenta um novo valor em uma chave existente dentro de um objeto formData, ou adiciona a chave se ela ainda não existir.
formData.get - Retorna o primeiro valor associado com uma chave dada dentro de um objeto formData.
formData.has - Retorna um valor boleano indicando se um objeto formData contém um certo par chave/valor.
onsubmit - Evento utilizado para submeter o formulário, quando é clicado algum botão direcionado a submit. Podendo executar uma ou mais functions fazendo
as validações que forem nescessárias.

- Desafio Flappy Bird.
. Desafio e criação de um flappy bird com o conteúdo visto nos capítulos anteriores como: flexbox, div, criação de componentes como elements. E técnicas 
que foram passadas.
. Quando não é utilizado a forma padrão de criação de jogos em html a parte da animação não será tão fluida. 
. O jogo será feito com o click de uma tecla com evento de subir o elemento representado pelo personagem do jogo, e quando estiver sem o click o 
personagem irá descer.
. Caso o elemento de personagem se choque com qualquer elemento obstáculo ele será barrado.
. E para cada elemento obstáculo que for ultrapassado contará um ponto.
. Será utilizado dois arquivos mencionados no arquivo flappy.html, que será:
flappy.js
flappy.css.

- Flappy Bird #01.
. Iniciando o projeto, começando pelo CSS, inserindo algumas classes CSS acrescentando manualmente dentro da DIV do HTML referente ao projeto.
. Implementando a parte estrutural em JS e via manipulação da DOM que é o objetivo do Desafio.
. Utilizando o arquivo CSS, inserindo os primeiros estilos. 
. No arquivo HTML, inserido a imagem do elemento personagem e os elementos obstáculos dentro da div wm-flappy.
. Para os elementos obstáculos será utilizado o método Flex Box e suas propriedades. 

- Flappy Bird #02.
. Comentando o conteúdo inserido na div na aula passada, e implementando o conteúdo a partir do arquivo flappy.js.
. Criando uma função para criar novos elementos a partir de uma tagName, e também será criado uma classe para esses novos elementos a partir de uma className.
. A função criada em seguida será referente ao elemento de obstáculos, dentro da função barreira, utilizando o this será inserido o que será criado a partir de um novo
elemento DOM, recebendo as classes de Barreira, Borda e Corpo, dentro da div. 
. Criando elementos para as respectivas classes citadas acima a partir do this.
. Definindo com appendChild a estrutura reversa ou não reversa para o corpo e borda dos elementos barreira.
. A função inserida a seguir será sobre a altura e a abertura entre os elementos barreira, definindo também um novo elemento para um obstáculo superior e inferior e os declarando na DOM.
. A próxima função inserida será o cálculo de valores referente a abertura entre os elementos barreira, pois não será um valor e um posicionamento fixo.
. Inserindo um this para o elemento continuar retornando também o valor no eixo X do tamanho no elemento barreira, e também inserindo um this para fazer a animação do elemento obstáculo, conforme o 
jogo está em andamento e o this referente a largura a dimensão do dispositivo que está sendo utilizado. 

- Flappy Bird #03.
. Nessa aula, dando continuação ao exercício será criado uma função referente ao elemento obstáculo para definir a altura, largura, abertura e espaços entre um obstáculo e outro. 
. Tendo uma função que será para o controle de múltiplas barreiras reaproveitando e passando as mesmas dentro do jogo, porém com valores alternativos de tamanho.
. Criando uma função para deslocamento inicial das barreiras em direção ao fim da área do jogo. 
. A partir de uma const para criação de um this.animar que reberá a função de animação e deslocamento dos elementos barreira e os definindo na altura e largura da proporção da área do jogo.

- Flappy Bird #04.
. Continuação do projeto...
. Criando uma função para receber um novo elemento a partir de this que será o personagem do jogo, e também referenciando o local onde está a imagem.
. Utlizando o eixo Y a partir de um this.getY para localizar a posição do personagem, e com o setY para que o personagem só faça a animação na altura permitida.
. Criando eventos para quando um usuário clicar em alguma tecla o personagem começe a subir e quando soltar a tecla o personagem começe a descer.
. Introduzindo o personagem e a área do jogo para teste no html.

- Flappy Bird #05.
. Defindo a parte do progresso do jogo a partir e uma função, definindo com a pontuação 0 e para cada elemento barreira ultrapassado pelo personagem será contabilizado um ponto no progresso.
. Criando uma função progresso, para contabilizar os pontos e atualizar. 
. Adicionando os pontos na área do jogo.
. Criando um elemento a partir de this para o start do jogo, com o temporizador de indicando as animações de barreira e personagem.

- Flappy Bird #06.
. Finalizando o desafio.
. Criando uma checagem de colisão para quando os elementos personagem e barreira fiquem sobrepostos no mesmo eixo x e y seja finalizada a partida. 
. Criando uma função para a sobreposição dos elementos.

Seção 16: Ajax

- Baixando o Arquivo Zip.
. Focando no JS e requisições assíncronas utilizando a técnica Ajax.

- O que é Ajax?
. Ajax é a sigla de Asynchronous JavaScript And Xml.
. Técnica usada com JS, para ter requisições assíncronas, resolvendo problemas como espera de carregamento em uma página web ao ser enviada uma requisição ao servidor, faz com que a 
requisição seja disparada através do JS e não diretamente pelo browser. Atualizando a página web ou parte dela sem recarregar (reload).
. Ocorre uma comunicação assíncrona com um servidor web ou seja, envia e recebe dados em background.
. A técnica Ajax funciona por conta do Padrão de Projeto Observer. Podendo trabalhar também com Json.

- Implementando server.js.
. Implementando o servidor que será utilizado no capítulo para provê os arquivos estáticos e criar serviços no backend.
. Criar um arquivo package.json. E instalando as dependências.
    - Nodemon
    - Body-parser 
    - Express
    - Multer
. Dependência para desenvolvimento: Nodemon.
. Criação de um arquivo JS para ser responsável para provê os dados estáticos e para serviços caso seja necessário submeter formulários e outros...
. No arquivo serve.js será importado os módulos citados acima, definindo os middleware que serão aplicados sempre que ocorre uma requisição, sendo uma função que será 
executada quando uma determinada requisição do padrão de URL, ou podendo aplicar em todas as outras requisições que chegarem ao servidor.
http://localhost:8080/.

- XMLHttpRequest #01.
. Implementado de uma forma manual definindo uma função em JS e dentro uma requisição Ajax. 
XMLHttpRequest - Objeto padronizado do JS, que fornece funcionalidades ao cliente para transferir dados entre um cliente e um servidor, de uma maneira fácil de recuperar dados de um
URL sem ter que fazer uma atualização da página.
. Ao criar uma função ajax, receberá um objeto com todos os parâmetros de configuração, possuindo o parâmetro método, url e também possuindo as funções de sucesso e erro da aplicação.
. Criando uma tabela com a DOM associando com Ajax. Ao fazer uma requisição com Ajax no momento que receber a resposta será renderizado uma tabela.
xhr.onload - Evento que é acionado quando uma XMLHttpRequest transação é concluída com sucesso.
xhr.open - Inicializa uma nova requisição ou reinicializa uma requisição já existente.
xhr.status - Propriedade de leitura que retorna o código de status HTTP numérico da XMLHttpRequest resposta. 
xhr.send - Envia uma requisição para o servidor.

- XMLHttpRequest #02.
. Exercício sobre upload utilizando XMLHttpRequest.
. Importanto o multer para o arquivo servidor em JS, isso fará com que ele interprete o formulário.
multer.diskStorage - Recebe um objeto e faz a configuração da pasta e arquivos, personalizando para salvar.
. Quando é realizado um upload de arquivo, o arquivo é colocado dentro de uma pasta e não para o banco de dados. É mudado o nome do arquivo para que não ocorra de ter dois arquivos com o mesmo nome. 
. Para evitar o nome duplicado em arquivos é utilizado prefixos.
. Ao Utilizar o multer.diskStorage é criado um função para o local de destino, e uma função para o nome do arquivo ser alterado.
. É feito uma requisição via POST para fazer o upload do arquivo e a url de onde o arquivo será encontrado, que no caso será a pasta.
. Dentro da requisição é feito uma função com os parâmetros de requisição resposta e erro.
. Caso esteja tudo certo, retornará para resposta uma mensagem: "Concluído com sucesso", caso ocorra algum erro será retornado uma mensagem: "Ocorreu um erro".
. Implementando no arquivo em HTML a técnica Ajax.
. Na tag script a partir de uma função com o parâmetro de configuração, terá o XMLHttpRequest para recebimento da requisição.
. Dentro da função terá uma estrutura de controle a qual receberá o upload e verificará o progresso do mesmo.
xhr.onprogress - Evento que ocorre quando o navegador está baixando algum arquivo.
. Tendo uma função para o upload, com os parâmetros da primeira função, para executa-lá também será feito o evento para que assim que for selecionado o arquivo, seja iniciado o upload. 
onchange - Executa uma função em JS quando um usuário altera a opção selecionada de um elemento <select>.

- XMLHttpRequest #03.
. Implementando dados via ajax no modelo XML.
. Declarando uma função ajax como nas aulas anteriores com o parâmetro de configuração.
xhr.onreadystatechange - Contém um manipulador de eventos que é chamado quando o evento readystatechange é disparado, ou seja, toda vez que a propriedade readyState do XMLHttpRequest é modificada.
Mantém o status do XMLHttpRequest.
0 - Pedido não inicializado
1 - Conexão do servidor estabelecida
2 - Pedido recebido
3 - Processamento do pedido
4 - Pedido finalizado e resposta pronta
. Declarando dentro da função ajax, as funções de status com a configuração de sucesso que terá como parâmetro a resposta 4 da propriedade readyState, e também declarando a função erro para caso não seja
executado conforme a propriedade.
. Executando a função ajax passando em um objeto, a url do arquivo em XML, o método get para recebimento do arquivo na aplicação. 
. A função de sucesso será a resposta do arquivo com os elementos em um array.
. Para percorrer o array será aplicado o método reduce para recebe os parâmetros de html e estado, e transforma em um único elemento final.
. Os parâmetros html e estado, será o acumulador formado pelos elementos do tipo <li> com nome e valor dentro de cada um dos estados.

- Fetch API #01.
. Forma de realizar requisições em Ajax sem utilizar nenhum framework por pertencer no próprio browser.
. Tendo vantagens ao utilizar pois o nível de abstração será maior.
. Sendo suportado 87% em todos os browsers.
. Será feito uma requisição get para envio do arquivo utilizado durante a seção. 
fetch() - É uma função que possui retorno em promisses, podendo receber json e convertendo o mesmo para dados em html.

- Fetch API #02.
. Fazendo uma submissão de um formulário a partir do método fetch.
. Será feita uma função no servidor com o método post onde terá os parâmetros de requisição e resposta do formulário.
. Dentro da função será inserido a resposta que terá dentro a requisição e o body, junto com o id do usuário ao ser inserido.
. Sendo interceptado pelo bodyParser.
. No arquivo html, será implementado a partir da tag script.
onsubmit - Evento utilizado para submeter o formulário, quando é clicado algum botão direcionado a submit. Podendo executar uma ou mais functions fazendo
. Criando uma função async para retornar um promisse.
. Fetch para receber as informações digitadas e converter-las como json. 
. Await para retornar como resposta de submissão do formulário os valoresinseridos pelo usuário, constando nome, sobrenome, fomrData: ajax e id.

- Axios #01.
. Sendo também um cliente HTTP, porém não suportado por padrão no browser por não possui uma biblioteca própria.
. Ao importa-lo para aplicação terá uma compatibilidade maior que o Fetch.
. Utilizando o mesmo arquivo de estados, e implementa-lo com axios, fazendo uma requesição get.
. Baseado em retorno de promisses, tem uma estrutura parecida com Fetch.

- Axios #02.
. Criando uma função no servidor com o método get atendendo a URL informada.  
. No arquivo html na tag script, será incluido a requisição que receberá e mostrará na web o resultado do get/post.
. Implementando com axios para fazer uma requesição get, que verificara se o número é par ou ímpar. 
. Ao implementar com post será possível inserir o nome, sobrenome e gerará um id ao ser criado. 

- Ajax com jQuery.
. jQuery é uma biblioteca livre que contém funções do JS que é possível fazer requisições como get, post em páginas HTML.
. Realizando uma requisição via Ajax a partir de uma API do jQuery.
. Utilizando a função descrita na aula passada. 
$. - Representação do jQuery em uma função.

- Carregando HTML via Ajax.
. Fazendo uma SPA - Single-Page Application. Mas não sendo uma aplicação e sim uma navegação com Ajax, tendo os princípios de SPA respeitados.
. Utilizado o arquivo index.html dentro da pasta ../spa.
. Carregando outro HTML através de uma requisição Ajax, e controlando o histórico através do JS .
. Revisão dos conteúdos e implementando no exercício.
 
Seção 17: Gulp.

- Introdução do Módulo.
. Gulp é uma ferramenta que auxilia no fluxo de trabalho, automatizando as tarefas que precisam ser feitas em um projeto.
. Sendo possível utiliza-lo também fora do contexto de desenvolvimento da aplicação, mas o foco do capítulo e entender como o gulp automatiza determinados fluxos 
e automatização de processos dentro da aplicação. 

- Documentação do Gulp.
. Verificando o site do Gulp e a documentação que o mesmo possui.
. Site: gulpjs.com - Automatizar e melhorar o seu workflow.
Workflow - É uma das partes que são realizadas dentro de um ambiente de desenvolvimento.
. No site possui um link onde direciona a documentação constando a instalação e configuração, e a parte de API do gulp, possuindo abas de funções importantes
que serão utilizadas no decorrer do capítulo. 

Forma de instalar a partir do terminal:
npm install gulp-cli -g
npm install gulp -D
npx -p touch nodetouch gulpfile.Js
gulp --help 

- Entendendo o Gulp.
. Exemplo de uso Gulp. Trazendo a motivação e como utilizar como ferramenta de trabalho.
. Existem frameworks que já embutem ferramentas como webpack, que na vem embutida no Vue internamente, no React, e essas ferramentas
são fundamentais para o auxilio.
. Tendo uma aplicação contendo diversas pastas e arquivos, que serão utilizados no desenvolvimento da aplicação.
. Entre os projetos de desenvolvivento (Dev) e o projeto que será inserido em produção a uma diferença relativamente grande. 
. Uma das coisas é quando o se tem um servidor web que será feita as requisições, no mesmo, normalmente a primeira requisição será para um arquivo em HTML, então
será feito o acesso do arquivo na aplicação em HTML, o servidor mostrará o arquivo solicitado. 
Por exemplo:
Req. (Index.html) -------- Servidor -------- Res. Index.html
. O browser será o que receberá o arquivo index.html através de um navegador. 
. Dentro desse arquivo contém referências para um arquivo CSS, um arquivo JS, imagens entre outros...
. Ou seja será utilizada diversas requisições que são feitas para trazer todos os arquivos necessários para que a página seja renderizada. Normalmente se inicia em um arquivo em HTML
e dentro do HTML possui uma série de referências para outros arquivos. 
. Dentro do projeto de desenvolvimento possui muitos outros arquivos, por exemplo, será quebrado a aplicação em diversos arquivos diferentes para se ter uma organização mais precisa, e 
que facilite outras pessoas que estarão desenvolvendo junto.
. Um dos cenários mais clássicos do Gulp é o fato de selecionar todos os arquivos em desenvolvimento que irão para produção e os converte-lo gerando um workflow para gerar o ambiente de 
produção, onde pode possui apenas alguns arquivos em HTML e JS.
. Os workflows que otimizam e facilitam o desenvolvimento de produção são automatizados usando o Gulp.
. O Gulp junto com plugins é possível converter algumas linguagens para a liguagem utilizada na aplicação ou que o browser consiga interpretar.

- Baixando o Arquivo Inicial.
. Baixando e instalando os arquivos que serão utilizados durante o capítulo.
. Nesse capítulo o foco não será códigos e sim a configuração do Gulp. 

- Atualização do Gulp-Sass.
. Nessa aula será instalada as dependências do projeto que será utilizada no decorrer do curso.
. Caso ocorra um erro ao instalar a dependência glup-sass, atualize no arquivo package.json para a versão 5.0.0
. Salvando o arquivo para atualiza-lo. 

- Instalando o Gulp e as Dependências.
. Instalando as dependências que serão utilizadas no capítulo.
. Executando o npm i para criação dos arquivos package.json e package-lock
. Instalar as bibliotecas do Gulp:
npm i -g gulp-cli
npm i gulp -D
. CLI (Command-line Interface) - Processa os comandos que serão enviados para um programa na forma de linhas de texto.
. Dentro da pasta Gulp através do terminal será instalado:
devDependencies
babel-core  
babel-preset-env 
gulp                   
gulp-babel   - Integração do Gulp com Babel.      
gulp-concat  - Serve para concatenar os arquivos. 
gulp-sass    - Pré processador CSS, plugin que intrega o Gulp com Sass
gulp-typescript  - Plugin que integra o Gulp com TypeScript.
gulp-uglify - Fará com que um arquivo JS vire um arquivo dentro de somente uma linha de código. Sem espaços e reduzindo o máximo possível.
gulp-uglifycss - Sendo a mesma utilidade que o uglify porém apenas com CSS.
typescript - Dependência própria do typescript.
. Gulp é centrado em funções que executam tarefas, normalmente as tarefas são executadas de forma paralela. Executando em séries que possuem parâmetros.
Caso uma das tarefas dê problema todo o script irá parar, mas é possível acrescentar flags que o tornará robusto, continuando as tarefas. 
. Possuindo um CLI para utilizar o gulp no terminal da aplicação.

- Fundamentos de Gulp #01.
. Gulp é um framework baseado em funções e as funções são conhecidas como tarefas (task).
. Então basicamente terão uma série de funções que são uma série de tarefas que vão automatizar os processos dentro da aplicação, as tarefas podem ser executadas
de formas sequênciais ou de forma serial, sendo uma tarefa depois da outra, ou dependendo do tipo de cenário que está sendo desenvolvido uma aplicação é possível 
paralelizar as tarefas para serem executadas de forma paralela.
Por exemplo: Juntando todos os arquivos CSS em um arquivo só, ou juntar todos os arquivos JavaScript da aplicação em um arquivo só, claramente é visível que está sendo feito 
o recolhimento de diversos arquivos de diferentes tipos como JS e CSS, juntando em um arquivo. Não possuindo uma dependência entre as tarefas. 
. É possível um arquivo formatado em JS ser minificado, otimizando o código para economizar espaço reduzindo apenas para uma única linha 
tirando todos os espaços em branco. 
. Utilizando o arquivo gulpfile.js será importado o gulp a partir de um require. 
. Será feita uma função com o parâmetro de callback que será chamada assim que uma determinada tarefa foi finalizada, sendo uma forma de notificar o Gulp que uma determinada 
tarefa foi concluída. 
. Ao final da função será invocada a mesma função sendo executada pelo gulp. 
. Exportando atráves do module.exports o series() com a função criada acima entre parênteses.
. O Gulp espera receber uma task Default ao exportar alguma tarefa.
module.export.default - Será para criar uma task default caso ao ser exportado uma task.

- Fundamentos de Gulp #02.
. Continuação do exercício abordando os fundamentos do Gulp.
parallel() - Combina funções de tarefas ou operações compostas que serão executadas simultaneamente. Não possuindo na profundidade de aninhamento de operações
compostas usando series()e parallel().
gulp.src() - Seleciona os arquivos que serão utilizados como entrada para o workflow que está sendo definindo.
 .pipe() - Função que transformará ou aplicar transformações nos arquivos que são definidos.
gulp.dest - Coloca os arquivos definidos em um outro local a ser declarado. 
. Então a ideia do Gulp é ser uma ferramenta que vai estar sempre trabalhando com funções e essas funções são conhecidas como task, então a ideia é a criação dessas 
funções que realizam transformações em conjuntos de arquivos colocando as funções em paralelo em série.

- O que é Babel?
Site: babeljs.io
. Babel é um compilador Javascript, usado para que seja possível utilizar recursos do JS conforme a sua atualização se estende.
. Antes mesmo que seja atualizado nos browsers, fará com que a compilação seja interpretada de forma correta no browser que está sendo 
utilizado.
. Será utilizado nos próximos exercícios.

- Processando JavaScript com Gulp.
. Implementando o exercício de JS.
. Utilizando a pasta Javascript dentro possui a pasta src e dentro possuem dois arquivos em JS serão utilizados nessa aula.
. Ainda na pasta JS, será feito o Workflow a partir do arquivo gulpfile.js.
. Importando as dependências que será utilizada na aula.
babel() - O babel é um transpilador para converter o código antigo e gerar, um novo código em JS.
 comments: - Não colocará os comentários feitos no código. 
 presets: ["env"] - Módulo especial que compilará o código para uma versão anterior do ECMAScript caso o recurso que está sendo utilizado não seja suportado pelo browser.
uglify() - Não é necessário passar nenhum parâmentro, fará com que o código seja minificado.
concat() - Os arquivos serão concatenados na ordem em que forem especificados nos parâmetros.
.pipe - Realiza chamada de funções passando a saída de uma função para a entrada de outra. 
gulp.dest - Destino de onde será compilado o arquivo.

- O que é TypeScript?
Site: typescriptlang.org
. É um superconjunto de Javascript, ou seja tudo que o javascript possui é suportado pelo typescript, pois o mesmo não é uma linguagem independente, sendo
escrito em typescript e sempre será convertido em javascript.
. A ideia do core em typescript é a possibilidade de colocar tipagem no javascript. Fazendo com que seja feita algumas verificações, ou até mesmo o compilador
reconheça diversos problemas por conta da liguagem tipada.
. Possui uma série de funcionalidades para utilizar typescript, utilizada com Angula, React, aplicações backend com o Node.
. Será feito a conversão do arquivo através do gulp com o plugin typescript para a conversão nas próximas aulas. 

- Processando TypeScript com Gulp. 
. Implementado o exercício de typescript.
. Serão utilizado a pasta typescript e seus arquivos TS. 
dir - Executando no terminal mostra os diretórios que a pasta possui.
. No arquivo gulpfile.js será definido o Workflow. 
. Criando uma constante que será o arquivo de configuração que o JS utiliza para transformação do arquivo TS.
. Criando uma função para executar a transformação TS será retornada a const criada acima. 
. Utilizando as configurações citadas na aula passada para fazer a integração.

- O que é SASS?
Site: sass-lang.org
. Pré Processador CSS - É possível colocar novas funcionalidades que não estão disponíveis no CSS para auxiliar a ter um CSS com maior nível de reúso, e 
os Sass é o mais conhecido entre os pré processadores. 
. Fazendo com que seja o pré processador mais maduro, estável e mais utilizado no mundo. - Segundo o Site.

- Correção para problemas com npm install.
Devido às novas versões do SASS, ao tentar instalá-lo com os arquivos disponibilizados no curso, um pequeno erro pode vir a acontecer.

1 - Delete a pasta node_modules do seu projeto
2 - Abra o arquivo package.json
3 - Dentro do arquivo, procure nas dependências a linha referente ao node-sass e/ou sass e delete a linha
4 - Salve o arquivo
5 - Use o comando npm install no seu projeto normalmente
6 - Agora utilize o comando npm install node-sass gulp-sass --save-dev
Com isso o problema deve ser corrigido.

- Processando SASS com Gulp #01.
. Realizando o processamento utilizando os arquivos SASS. Gerando uma pasta com o resultado final da aplicação.
. Importando as dependências: gulp, gulp-sass, gulp-uglifycss, gulp-concat
. Utilizando os mesmos métodos de configuração e funções das aulas anteriores porém para arquivos SCSS, e também utilizando as depêndencias acima.
. Otimizando o arquivo CSS para pasta build.

- Processando SASS com Gulp #02.
. Utilizando o mesmo arquivo para criação de outras tarefas.
. Tarefa que será gerado a otimização do work e uma página web com o arquivo html e o arquivo CSS utilizado nas aulas anteriores. 

- Projeto SPA: Estrutura do Projeto.
. Criando o projeto final do capítulo, sendo um workflow mais complexo.
. Utilizando a pasta SPA.
. O exercício terá o seu próprio package-json, e será criado uma build que gerar os arquivos, e um servidor para quando ocorra mudanças será atualizado.
. Instalando as dependências já declaradas no arquivo package-json.

- Projeto SPA: Criando a Estrutura do Build.
npm audit fix - Comando que permite fazer verificações de segurança.
. Definindo a estrutura da build, criando uma pasta gulpTask.
. Dentro da pasta gulpTask será criado três arquivos para a criação a build do projeto. 
app.js - Arquivo para as Tasks relacionadas aos códigos da aplicação.
deps.js - Arquivo para importação das dependências que serão utilizadas.
servidor.js - Controle do servidor, que será utilizado em desenvolvimento, auxiliando a automatização dos arquivos. Então qualquer arquivo que for atualizado será
restartado a aplicação. 
. Definindo todas as funções nos arquivos para importar ao gulpfile.js.
. No arquivo gulpfile será importado as dependências e arquivos, importando o series e o parallel.
. Importando a dependencia gulp.
. Será feita constantes com as funções declaradas em um objeto e que receberá os arquivos que as mesmas contém dentro.
module.exports.default - Será definido o workflow que será utilizado nas funções.  

- Projeto SPA: Task Dependências.
. Com a build ja definida, será o momento de preenchimento das tasks.
. O primeiro arquivo a ser preenchido será o deps.js. 
. Na primeira função: será copiado o caminho da font através da pasta no node_modules, inserindo o mesmo no gulp.src.
. Será feito a introdução do pipe para executar as depêndencias do uglifycss, concat, também será chamado o destino do arquivo quando estiver pronto. 
. Implementando a task de fonts, com base na mesma configuração da task anterior.

- Projeto SPA: Task Aplicação.
. Implementando a parte da build no arquivo app.js.
. Importando as dependências que serão nescessárias para a task. E fazendo uma estrutura semelhante a anterior para as tasks relacionadas
a html, css, js e img.
collapseWhitespace - Retira os espaços em branco.

- Projeto SPA: Task Servidor.
. Configurando a ultima parte da build, da aplicação spa.
. Configurando o servidor.js, que irá monitorar os arquivos.
. Utilizando a dependência WebServer, e configurando para as requisições executarem de maneira correta.

- Conclusão do Módulo.
. Finalização do Módulo

- Código final do Capítulo.
. Recursos do capítulo em zip.

Seção 18: Webpack.

- Visão Geral do Webpack.
. Webpack tem o mesmo propósito do Gulp, auxiliando a automatização da build, porém de maneiras diferentes.
. Enquanto o gulp trabalha com task executando uma após a outra ou até mesmo paralelamente. O webpack é completamente
baseado em sistemas de módulos, possuindo dois grandes sistemas principais de módulos do JS. 
. Sendo o CommonJS utilizando com o node, possuindo o module.exports para exportação e a função require para importação.
. Existe um outro módulo que veio com o ECMAScript2015, sendo oficial da linguagem JS, que é um sistema de módulos baseado em import e export. 
. Então o webpack é completamente feito em sistema de módulo. 
entry: - Propriedade que será utilizada no arquivo de configuração do webpack que irá indicar qual o módulo que deverá ser usado para dar início
loaders - Interpreta e permite gerenciar arquivos que não são Javascript.

- Estrutura Básica do Projeto.
. Criando uma estrutura básica do capítulo utilizando o webpack.
. Criando um arquivo package.json e instalando as dependências necessárias: webpack e webpack-cli.
. Criando um arquivo em js em uma pasta src onde será criado um novo módulo contendo informações, e um outro arquivo que receberá a importação do 
primeiro arquivo criado.
webpack.config.js - Arquivo sendo interpretado pelo NodeJS, onde será feita a configuração do script do webpack.
mode: - Fornece a opção de configuração, informando para utilizar as otimizações internas de acordo, tendo as opções: 'production', 'development'. 

- Sistema de Módulos.
. Comparando o sistema de módulos do NodeJs com o do ECMAScript2015, sendo possível utilizar os dois, porém não é recomendado.
. O recomendado é que mantenha uma consistência no import ou export.

- Configurando a Pasta de Saída.
. Mudança na configuração de pasta.
output: {} - Serve para definir o nome e o local onde o módulo será enviado após a execução.

- Carregando Arquivos.css.
. Como funciona carregamento de um arquivo css na aplicação.
. Criação de uma pasta assets, o assets será sempre uma pasta para arquivos estáticos que sempre estão sendo modificados. 
. No arquivo de configuração do webpack será introduzido um novo module após o output, onde terá rules e loaders.
rules: [{}] - Define um conjunto de testes de caminho de arquivo e carregadores que devem ser usados quando um recurso que corresponda ao teste for encontrado
. Instalando as dependências para o css, css-loader e style-loader.
. Será introduzido dentro do arquivo principal.js, injetando via DOM, através do style-loader. 

- Externalizando Arquivos.css.
. Continuação do exercício de import e export do CSS. Instalando as depêndencias necessárias. 
mini-css-extract-plugin - Extrai o arquivo CSS para um arquivo específico em JS.
. Inserindo o plugin no arquivo de configuração do webpack.
. Realizando a configuração com um array que recebe uma função construtora, recebendo de parâmentro o plugin instalado. 
. Definindo o nome do arquivo CSS dentro da função através do filename.
. Inserido na configuração module, dentro de use: a função criada acima que extrai o arquivo css sendo mencionando o arquivo externo criado.

- Atualização - Dependência node-sass.
. Geralmente, o motivo dos erros é porque a versão do pacote node-sass usado na aula está descontinuada. Portanto, a solução é simplesmente usar a
versão mais recente do sass.
https://www.npmjs.com/package/node-sass

- Carregando Arquivo .SCSS (SASS).
. Utilizando o SASS com a configuração Webpack
. Instalando as depêndencias do sass no package.json
. No arquivo de configuração do webpack.js, será alterado a expressão para reconhecimento dos arquivos em sass e css.
regex101.com - A partir da expressão verifica qual arquivo poderá ser encontrado.
. No arquivo webpack.config será acrescentado no module: use: o plugin sass-loader. 
. Será criado na pasta assets uma pasta scss para criação dos arquivos scss, criando váriaveis referente a um botão.
. E um novo arquivo referente ao botão definindo as váriaveis criadas no outro anterior.
. Retornando na pasta assets será criado um arquivo index.js que será carregado por padrão sendo importado no arquivo principal.
. No arquivo index.js será importado os arquivos CSS e SCSS. 
. No arquivo index.html na pasta public, será criado o botão.

- Desenvolvimento & Produção.
. Ideia de criação de uma build específica para o desenvolvimento e uma build espefícica para a produção.
. Instalando as dependências necessárias para setar a varíavel de ambiente. Suportado nos três sistemas operacionais.
. E as dependencias para minificar os arquivos. 
cross-env 
optimize-css-assets-webpack-plugin 
uglifyjs-webpack-plugin
. No arquivo de configuração será mencionando em uma constante modoDev que receberá o plugin cross-env.
. No objeto module.exports será informado no mode a constante criada acima referente ao modoDev, com a opção, caso seja verdadeiro será
desenvolvimento, caso seja falso será para produção.
. Será criado as constantes também como plugins configuradores para minificação dos arquivos JS e CSS, sendo o Optimize e Uglify.
. Criando uma seção optimization sendo um objeto que receberá o minimizer mencionando os plugins instalados na aula.
npm run build - Executará a build configurada no webpack.

- Atualização.
Por motivos de incompatibilidade de versões, a biblioteca UglifyJs não está suportando ES6. Podemos resolver esse problema trocando a biblioteca 
pela Terser, que empenhará o mesmo papel.

1. No terminal
npm install terser-webpack-plugin --save-dev
2. Em webpack.config.js. Importe a lib:
const TerserPlugin = require('terser-webpack-plugin')
3. Em optimization, apague o seguinte trecho de código:
new UglifyJsPlugin({
    cache: true,
    parallel: true
}),
4. E remova o import de UglifyJsPlugin
// Remover
const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
5. Por fim, em plugins. Declare:
new TerserPlugin({
    parallel: true,
    terserOptions: {
        ecma: 6,
    },
}),
Com isso feito, o projeto deverá funcionar normalmente.

- Carregando Arquivos de Imagens.
. Recurso importante para aplicação, é a configuração a otimização de imagens atráves do webpack.
. Será criada uma pasta para receber imagens dentro da pasta assets. 
. Importando a url da imagem no arquivo estilo.css.
. Na configuração do webpack, uma vez mencionado o plugin css-loader, será sempre interpretado @import, urls entre outras menções de arquivos.
. Instalando a dependência file-loader e realizando a configuração para o carregamento de teste de diversas extensões de imagem.

- Adicionando WebServer.
. Adicionando na configuração do webpack o WebServer.
. Instalando a depêndencia ao package.json.
. Configurando o servidor para o local de endereço: http://localhost:9000

Seção 19: jQuery

- Baixando o Zip.
. Instalando o ZIP do capítulo atual.

- O que é jQuery?
. É uma biblioteca JS, ajudando na busca de elementos e alteração da DOM.
. Atua com manipulação de eventos, animações e ajax. 
. Utiliza os seletores para o CSS. Para localizar e consultar.
. Realiza o encadeamento de funções, executando uma após a outra apenas em uma linha.  
. Suportado por múltiplos browsers, e também é mais fácil a criação de plugins.

- Entendendo jQuery.
https://jquery.com/ - Site para instalação das versões do jQuery.
https://releases.jquery.com/ - (CDN) Importando o jQuery, através de uma referência via JS.
. Para referenciar jQuery em um código é necessário iniciar com o dollar. 
. É possível referencia-lo através de uma função, possindo diferentes parâmetros. 
.hide - Evento utilizado para ocultar conteúdo com jQuery.
.show - Evento show é utilizado para apresentar conteúdo que está oculto com jQuery.
.fadeOut - Oculta os elementos correspondentes tornando-os transparentes.
.get - Para que seja visivel os elementos correpondentes na DOM.
. jQuery é uma API que tem foco em consultar elementos de uma página e manipula-los de alguma forma.
$.isEmptyObject() - Função que é utilizada para verificar se o objeto está vazio.
jQuery.inArray - Procura um valor especificado dentro de um array e retorna seu índice.
$.fn - É possível criar plugins, extendendo as funcionalidades com suas próprias funções.

- Selecionando Elementos #01.
. Selecionando objetos a partir do jQuery, sendo possível através de seletores ou filtros que é uma forma mais 
refinada para selecionar.
$('') - Para selecionar um elemento a partir de um ID, Tag, class, atributos, herdeiro de um elemento,
.addClass - Adiciona a classe, anexando-a a qualquer uma que já possa estar sendo atribuída aos elementos. Mais
de uma classe pode ser adicionada ao mesmo tempo, separadas por um espaço
.removeClass -  Método para remover a classe específica de um elemento. 
Exemplos de filtros próprios do jQuery:
        $('li:first') - Seleciona o primeiro elemento de uma tag declarada.
        $('li:odd') - Seleciona todos os elemento que estão em índices ímpares de uma tag declarada.
        $('li:gt(1)') - Seleciona o índice maior que o índice mencionado entre ().
        $('li:not(:last) - Seleciona qualquer elemento menos o último de uma tag declarada.
        $('li:contains("r")') - Seleciona o elemento que possuí a string mencionada em ("").
        $('form *') - Seleciona todos os elementos de um formulário.
        $('form:text') - Seleciona os elementos do tipo texto.
        $('form:password') - Seleciona os elementos do tipo password.
        $('form:checkbox') - Seleciona os elementos do tipo checkbox.
        $('form:radio') - Seleciona os elementos do tipo radio.
        $('form:file') - Seleciona os elementos do tipo file.

- Selecionando Elementos #02.
. Exercício voltado para seleção de elementos, porém a partir de heranças, parents entre outros.
. Serão criados dois objetos contendo a propriedade de CSS para inserir ou não bordas na página.
.prev() - Retorna o elemento irmão anterior do elemento selecionado.
.parent() - Método que percorre o pai imediato de um elemento na árvore DOM e constrói um novo objeto jQuery a partir dos elementos correspondentes.
.next() - Método que permite pesquisar o elemento seguinte. 
.css() - Método utilizado para manipulação do CSS.
.parentsUntil() - Método que percorre os ancestrais desses elementos até atingir um elemento correspondente ao seletor mencionado.
.children() - Utilizado para encontrar todos os elementos filhos relacionados aquele elemento selecionado.
.find() - Método que serve para encontrar elementos descendentes dos selectores especificados.
.each() - Função utilizada para iterar um conjunto de elementos.

- Modificando HTML #01.
. Adicionando novos elementos a página web.
$('<li></li>).append() - Adiciona o elementos a uma tag referenciada.
.prepend() - Insere o conteúdo especificado no início dos elementos selecionados.
. Modificando e adicionando elementos a página e criando a partir de jQuery.

- Modificando HTML #02.
. Ulizando as funções já vistas no capítulo atual e no capítulo da DOM.
.appendTo() - Método que um elemento é selecionado e inserido, cuja a identificação á passada como parâmentro.
.prependTo() - Método para inserir elementos HTML no início do elemento selecionado.
.insertBefore() - Insere elementos HTML antes  dos elementos selecionados.
.insertAfter() -  insere elementos HTML depois dos elementos selecionados.
.replaceWith() - Método que substitui os elementos selecionados por um novo conteúdo.
.replaceAll() - Método que substitui todos os elementos selecionado por novos elementos declarados.
.wrap() - Método que agrupa os elementos HTML especificados em torno de cada elemento selecionado.
.wrapAll() - Mesma funcionalidade do wrap, porém agrupando todos os elementos.
.empty() - Método que remove todos os nós filhos e o conteúdo dos elementos selecionados. 

- Modificando HTML #03.
. Desafio para manipulação da DOM com jQuery. Criando uma tabela percorrendo por uma sequência de um array.

- Modificando HTML #03. (Desafio)
$(document).ready - Função que será executada quando a página da DOM estiver pronta para execução do JS.
. Criando uma const para percorrer o array, possuindo outras constantes que irão possuir a tag table e td.
. Criando uma constante que receberá a tag table que irá possuir a propriedade CSS para definição das bordas da tabela. 

- Manipulando Atributos.
. Manipulando atributos a partir do jQuery.
.attr() - Método que define ou retorna atributos e valores dos elementos selecionados.
. Exercício referente a um relógio que será atualizado de 1000 em 1000 segundos, manipulando a partir do jQuery, contendo botões 
para aumentar ou diminuir o valor estipulado de 1000 segundos.
.toLocaleString() - Função que exibe qualquer data no formato e idioma mencionado.

- Manipulando CSS.
. Manipulando os arquivos CSS, a partir do jQuery.
.css() - Método utilizado para manipulação do CSS, podendo incluir ou alterar as propriedades declaradas.
. É possível adicionar mais de uma propriedade através de um objeto.
.hasClass() - Método que verifica se algum dos elementos selecionados possui um nome de classe mencionada.
.toggleClass() - Método que alterna entre adicionar e remover um ou mais nomes de classe dos elementos selecionados.

- Eventos #01.
. Manipulação de eventos atráves do jQuery.
. Sendo parecido com a manipulação com Js, porém sendo de mais alto nível atráves do jQuery.
. Será feito um evento constando a posição no eixo X e Y do mouse na página, e atualizando conforme a posição se altere.
. Também será criado um evento para caso o ponteiro do mouse saia da página seja pausado o número do último eixo capturado.
.on() - Função que registra um evento no jQuery.
mousemove - Evento que representa a movimentação do mouse.
mouseover - Evento que ocorre quando o ponteiro do mouse está sobre o elemento selecionado.
.off() - Remove os manipuladores de evento anexados ao método on().
mouseleave - Evento que ocorre quando o ponteiro do mouse sai do elemento selecionado.
. Criando um evento para cada click que o mouse realizar dentro da página 
.click() - Aciona o evento click ou anexa uma função para ser executada quando ocorre um evento click.
. Evento que será alterado o background a partir do teclado.
. O evento keyup ocorre quando uma tecla do teclado é liberada.
.keyup() - Método que aciona o evento keyup ou anexa uma função para ser executada quando ocorre um evento keyup.
.match() - Método compara uma string com uma expressão regular, retorna um array com as correspondências e  retorna null se
nenhuma correspondência for encontrada.

- Eventos #02.
. Segunda parte dos exercícios de eventos.
. Será criado um evento para quando o usuário passar o mouse em cima do elemento será destacado.
.hover() - Especifica as funções a serem executadas quando o ponteiro do mouse passa sobre os elementos selecionados.
.one() - Aumenta o tamanho do elemento e seu texto, passando com o ponteiro do mouse ou ao clicar no elemento.
.dblclick() - Evento que ocorre quando um elemento é clicado duas vezes.
.fadeIn() - Altera gradativamente a opacidade, para elementos selecionados, de oculto para visível.
. Criando uma mensagem de alerta após o mouse passar pelos elementos.
alert() - Método exibe uma caixa de alerta com uma mensagem e um botão OK.
. Criando um evento que mostrará no elemento a altura e largura da página ao ser redimensionada. 
$(window).resize - Método que aciona o evento de redimensionamento ou anexa uma função a ser executada quando ocorre um evento de redimensionamento.
. Evento que quando selecionado o texto escrito será mostrado em outro elemento o resultado.
e.target.selectionStart - Índice de inicio da seleção.
e.target.selectionEnd - Índice de fim da seleção.
e.target.value.substring - Mostrará o resultado da seleção da substring.

- Eventos #03.
. Propriedades que são encontradas no Objeto evento do jQuery.
. Mostrando as propriedades em dados, dos eventos que o jQuery possí. A partir do ponteiro do mouse, das teclas pressionadas do teclado, ou
posicionamento do mouse na página.
e.relatedTarget - Retorna qual elemento está sendo inserido ou encerrado com o movimento do mouse.
which - Mostará qual a tecla pressionada do teclado ou o clique do ponteiro.

- Animação #01.
. Utilizando as propriedades do jQuery para realizar animações nos elementos da página.
. Para realizar a animação será criado uma função para o click que retornará a callback com o evento de animação.
. Será definido também o tempo que será feito a animação.
.toggle() - Alterna entre hide() e show() para os elementos selecionados.
.fadeToggle() - Alterna entre os métodos fadeIn() e fadeOut().
.slideToggle() - Alterna entre slideUp() e slideDown() para os elementos selecionados.
.slideUp() - É ultilizado para deslizar um elemento para cima.
.slideDown() - É ultilizado para deslizar um elemento para baixo.

- Animação #02.
. Criando animações mais específicas utilizando CSS e jQuery
.animate() - É utilizada para criação de animações personalizadas. 
. Será criado uma função com os parâmetros de valor dos tamanhos, duração e callback.
. Selecionando as divs da página e definindo os valores de altura e largura.
. Será declarado a duração e o callback para realizar uma animação após a outra.
. Criando uma função para movimentação do elemento na página, criando também uma função de girar, ambas funções irão possuir
o mesmo parâmentro que a primeira função criada. 

- Plugin #01.
. Criação de plugin, fazendo com que o JS realize a leitura e a conversão dos textos que estarão em duplas {}
. Criando uma função altamente invocada para o jQuery, com o parâmetro $, será introduzido as contantes para retirar as chaves das 
strings.
. Será feira uma constante que receberá o mapeamento do array com chaves e alteração do mesmo.

- Plugin #02.
. Realizando o último exercício do capítulo jQuery, será feito um temporizador, possuindo horas, minutos e segundos.
. Será associado dois arquivos para o temporizador, sendo um Js e outro CSS implementando os plugins.
. Na parte do jQuery, irá ser mencionado no plugin a div e o temporizador que receberá uma mensagem.
. No arquivo Temporizador.js será criado as funções para o temporizador ser inicializado a partir do horário mencionado, e as constantes
referente as horas, minutos e segundos. 
. Também será feito as constantes para o separador de horas, minutos e segundos. 
. Adicionando a classe para o temporizador ser localizado pelo CSS. E adicionando os outros elementos.
RegExp() - Construtor cria um objeto de expressão regular para combinar texto com um padrão.
.toISOString() - Retorna um objeto de data como uma string, usando o padrão ISO.
.getTime() - Retorna o número de milissegundos desde 1º de janeiro de 1970 00:00:00.

Seção 20: Bootstrap.

- Baixando o Zip.
. Baixando os arquivos do projeto final do Curso.
. Instalando as dependências declaradas no package.json e a dependência jQuery e Popper, nas versões exatas informadas no curso.

- Links úteis.
Links informados para consulta:
Link para download do ZIP: http://files.cod3r.com.br/curso-web/bootstrap.zip
GitHub da Cod3r: https://github.com/cod3rcursos
Repositório do curso: https://github.com/cod3rcursos/web-moderno
Repositório da seção: https://github.com/cod3rcursos/web-moderno/tree/master/exercicios-web/bootstrap

- Opções de Instalação.
https://getbootstrap.com/ - Site Bootstrap.
. Podendo ser instalado de diversas maneira. Lembrando que o bootstrap depende do jQuery.
. Vizualização do site.  

- Projeto Galeria.
. Atualização nas dependências:
1- Abra o seu projeto
2- Apague a pasta node_modules e o arquivo package-lock.json para garantir que não ficará nenhuma referência antiga
3- No arquivo package.json substitua as linhas referentes às dependências do node-sass, sass-loader, webpack por:
"node-sass": "4.14.1",
"sass-loader": "^7.3.1",
"webpack": "4.4.0",
4- E por fim, no terminal, dentro da pasta do projeto, rode o comando:
npm i

- Adicionando Navegação.
. Criação da navbar, para navegação dos exercícios.
. Copiando referência de Navbar do bootstrap, alterando nomes, referências de link e incluindo local de destino.

- Tipografia.
. O bootstrap possuí tipografias que auxiliam na configuração de estilos, o bootstrap padroniza em alguns estilos como:
Reboot - Torna consistente o estilo entre diferentes browser!
Rems - Baseado no raiz
Evita margin-top - Provavelmente será necessário adicionar algum espaço
box-sizing border-box
Fontes nativas
https://www.creative-tim.com/ - Site de Templates para Bootstrap
https://wrapbootstrap.com/ - Site de Templates para Bootstrap

- Espaços (Margin & Padding).
. Exercício sobre as class de espaçamento pré definidas do Bootstrap.
m - Margin      p - Padding
t - Top         e - End
b - button      s - Start
x - Eixo X      y - Eixo Y 
l - Left        r - Right
auto - Preenchimento automático.
. Os valores pré definidas pelo Bootstrap serão de 0 a 5.

- Título & Breadcrumb.
. Cabeçalhos e Breadcrumb
Breadcrumb - É o sistema de navegação por categorias existente dentro de um site. O que facilita a navegação do usuário e indica o caminho que percorre 
dentro de sua estrutura.
jumbotron - Componente leve e flexível para exibir o conteúdo com estilo, podendo estender toda a janela de visualização.
. Incluindo e alternando em todos os arquivos para Título e o cabeçalho realizado no exercício.
https://getbootstrap.com/docs/4.0/components/breadcrumb/

- Cores.
. Bootstrap possui cores pré definidas na documentação.
https://getbootstrap.com/docs/5.3/customize/color/
. A utilização das cores são bem presentes, seguindo um padrão que está descrito no site.
. Podem ser definidas nas classes assim como a medida quando declarada. 
. Exemplo: .my-1.p-3 bg-primary - Retornará um campo de margin 1 no eixo Y com o padding 3 e a cor primária azul.
 
- Flexbox.
. É um recurso recente, incluíndo na versão 4.0 do Bootstrap.
. Exercício referente ao flexbox no Bootstrap.
. Disponível na documentação do bootstrap as maneiras de declaração do flexbox, podendo associar a responsividade.
. É possível definir os tamanhos para responsividade:
sm - Small (Pequeno)
md - Medium (Médio)
lg - Large (Grande)
xl (Extra Grande)
https://getbootstrap.com/docs/5.3/utilities/flex/ 

- Imagens.
. Exemplos de incluíndo imagens e utilizando o Bootstrap.
img-thumbnail - Acrescenta uma borda arredondada de 1px na imagem.
img-fluid - Redimensiona a imagem de acordo com o tamanho da página ou dispositivo.
https://getbootstrap.com/docs/4.0/content/images/

- Float.
. Class CSS para trabalhar com Float.
. Conceito de Float - Capítulo HTML.
. Classes descritas na documentação.
https://getbootstrap.com/docs/4.0/utilities/float/

- Sistema de Grid #01.
. Principal recurso do Bootstrap.
. Sistema de grid linhas e 12 colunas. Antes para layouts eram utilizado as tags para table.
. Porém quando é utilizada em formulários, será feito uma distorsão não sendo recomendado utilizar a tag table.
https://getbootstrap.com/docs/4.0/layout/grid/
. O sistema de grade do Bootstrap usa uma série de contêineres, linhas e colunas para fazer o layout e alinhar o conteúdo.
. É construído com flexbox e é totalmente responsivo. 
.col- - Extra pequeno <576px	
.col-sm- - Pequeno ≥576px	
.col-sm- - Médio ≥768px	
.col-lg- - Grande ≥992px	
.col-xl- - Extra grande ≥1200px
. Implementando a Grid Básica no arquivo respectivo.

- Sistema de Grid #02.
. Implementando a grid de 12 colunas com responsividade.
. Será visível de diferentes maneiras a partir do tamanho de resolução da página.

- Sistema de Grid #03.
. Continuação das implementações do exercício.
. Foco da aula será na quebra de linha para determinados tipos de grid.
w-100 - Classe dentro de uma div vázia para efetuar a quebra de linha.

- Sistema de Grid #04.
. Alternar a ordem dos elemento a partir de uma Grid.
order - Independente da ordem escrita, sempre será organizado de maneira crescente, sendo de 1 a 12 representando as 12 colunas.

- Sistema de Grid #05.
. Utilizando o Offset no sistemas de grid do Bootstrap, para deslocamento.
.order-classes para controlar a ordem visual do conteúdo. Essas classes são responsivas, portanto, podem ser definidas com o order ponto de
interrupção, por exemplo: .order-1.order-md-2

- Sistema de Grid #06.
. Sistema de Grid é baseado nos conceitos do flexbox.
. Podendo ser utilizado alguns itens para alinhamentos ou medidas.

- Botões.
. Exercício sobre os componentes.
. https://getbootstrap.com/docs/4.0/components/buttons/
. Alguns componentes será nescessário utilizar o JS, porém no exercício atual não será utilizado.
. Como o bootstrap é um framework, então boa parte dos componentes são definidos. E alguns de fato é necessário implementar
o Js para funcionar.
. Sendo possível implementar diversos tipos de botões: Botões normais, desabilitados, botões que ficam selecionados,
posicionamento dos botões, alternativas ao clicar no botão.
. Na documentação possuí outros tipos de botões.

- Barra de Progresso.
https://getbootstrap.com/docs/4.0/components/progress/
.progress - Utilizado como um wrapper para indicar o valor máximo da barra de progresso.
.progress-bar - Utilizado para indicar o progresso até agora. Possuindo um estilo embutido, classe de utilitário ou CSS
personalizado para definir sua largura.
. Também requer alguns atributos role e aria para torná-lo acessível.

- Alertas.
. Exercício de alertas e mensagens que podem ser incluídas.
. É possível incluir links, mensagens após o alerta, botão de saída, entre outros.
https://getbootstrap.com/docs/4.0/components/alerts/

- Paginação.
. Componente para barra de navagação entre páginas.
https://getbootstrap.com/docs/4.0/components/pagination/

- Tooltip.
. O Tooltip tem uma característica diferente dos anteriores, para funcionar necessita realizar uma chamada via JS com jQuery.
. Crinado no arquivo de Componentes.html, o Tooltip e um botão.
. No arquivo Navegação.js será incluido na função após a chamada do html.
eval(html.match(/\<script\>([\s\S]*)\<\/script\>/)) - Para coletar todo o texto escrito em tag script.

- Slider.
. Incluindo Slide na página utilizando bootstrap.
.carousel - É uma apresentação de slides para percorrer uma série de conteúdos, construído com transformações 3D CSS e um pouco de JavaScript.
https://getbootstrap.com/docs/4.0/components/carousel/

- Accordion.
. Implementando o componente de Accordion.
. É possível criar cartões que podem ter o comportamento de estendimento e recolhimento padrão.
https://getbootstrap.com/docs/4.0/components/collapse/#accordion-example

- Formulário.
. Criando um formlário a partir do bootstrap.
https://getbootstrap.com/docs/4.0/components/forms/
. Trazendo um visual clean para a página, na documentação possui outros exemplos.
. Bootstrap é bem utilizado para os templates trazendo facilidade e otimização.

Seção 21: Projeto Galeria (Bootstrap/jQuery/Webpack)

- Visão Geral do Projeto.
. Projeto voltado para revisão dos conteúdo vistos no curso até o momento, focando a parte de 
JS, jQuery, Bootstrap e Webpack.
. Conteúdo dentro da pasta de Bootstrap.
. Projeto Galeria de fotos que terá botões para filtrar as imagens. 
. Criando um plugin com jQuery para renderização dos botões de acordo com as imagens, e também filtrar de 
acordo com a seleção.
CopyWebpackPlugin - Plugin que realiza a cópia de arquivos html e imagens para diferentes tipos de pastas. Mantendo a mesma organização em
questão as páginas e pastas. 
. Todas as depêndencias estão fixas para não ocorrer problemas em compatibilidade com o curso.

- Referenciando os Estilos (SCSS).
. Iniciando o projeto trabalhando com o sass e font-awesome
. Instalando as dependências do package.json.
. Realizando a importação das dependências no arquivo index.scss

- Implementando o Header.
. Dentro da pasta src será criado uma pasta pages que irá ter uma pasta para templates.
. Na pasta template será criado um arquivo header.html, onde é possível coletar um exemplo de template e utilizar. Mas no exercício atual será
criado o arquivo manualmente.
. Criando a estrutura do header utilizando as funções do bootstrap vistas no capítulo anterior.

- Carregando HTML via Ajax (Includes).
. Implementando JS que fará a interceptação da propriedade declarada no index.html referenciando o arquivo de header.
. Será criado uma pasta e um arquivo para implementação. Importando o jQuery através do sistema de modulos do ECMAScript2015.
. Será feita uma função que irá ler todos os arquivos que irão ter o nome wm-includes

- Implementando a Galeria de Fotos.
. Criando uma pasta dentro da pasta pages, e dentro um arquivo galeryHeader e galery.html. 
. Definindo o arquivo header para ser utilizado e o galery para importação das imagens.
. Utilizando flexbox e o sistema de grid do bootstrap para definição dos elementos de acordo com a resolução da página.

- Filtrar Fotos por Cidades (jQuery Plugin).
. Implementando o plugin que irá gerar os botões e a partir dos botões será selecionado as imagens correspondentes.
. Será feita uma constante para animação.
. Definindo a função que irá filtrar as cidades a partir de uma função do jQuery.
. Será feita uma constante com new Set para cada imagem ter o seu botão respectivo, filtrando a partir do nome
. Criando o botão a partir de uma chamada do jQuery, e adicionando a função do filtro das imagens.
. Será criado um array para preencher com os botões, mapeamendo para cada botão clicado a imagem aparecer e as demais ficarem ocultas.

- Executando o Plugin.
. Quando é incluido uma página html via requisição Ajax, a partir da propriedade criada manualmente. E é necessário executar um arquivo Js, não é chamado por padrão.
. Será definido um Array de funções callback para requisições bem sucedidas. 
. Função criada para executar o callback sobre o array.
. Importanto a função para o arquivo de botões para funcionar corretamente.

- Implementando o Footer.
. Criando o footer da aplicação.
. Será criado um arquivo dentro da pasta de templates.
. Possuindo um span contendo um ícone e uma mensagem.
. Mencionando no arquivo HTML.
